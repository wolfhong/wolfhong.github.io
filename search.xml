<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>UPC、EAN、ISBN的编码介绍</title>
      <link href="/posts/intro-upc-ean-isbn/"/>
      <url>/posts/intro-upc-ean-isbn/</url>
      <content type="html"><![CDATA[<p>条形码(barcode)，也可以叫做一维码，在生活中广泛存在，包括常见的UPC、EAN、ISBN等等。<br>你看的每本书、喝的每瓶饮料、买的每件商品，基本都可以看到它们的身影。</p><h3 id="UPC的编码解析"><a href="#UPC的编码解析" class="headerlink" title="UPC的编码解析"></a>UPC的编码解析</h3><p>UPC(universal product code，通用产品代码，通常指UPC-A) 是最早投入使用的条形码，在美国、加拿大等欧美国家使用广泛。<br>尽管UPC很简单，但却是实现零售业结算和库存管理自动化的基础。<br>本文就从UPC着手讲解条形码是如何工作的，下文中的UPC的示例摘录自<a href="http://www.amazon.cn/gp/product/B009RSXIB4/">《编码:隐匿在计算机软硬件背后的语言》</a>。</p><p>通常情况下，UPC由30条不同宽度的垂直黑色条纹组成，条纹间由不同宽度的空白间隙分割开。<br>聪明的你一定想到了，这些条纹的含义就是条形码下方的数字，组成了该商品特有的编号。<br>只不过，下方的数字是方便人阅读，而条形码是方便计算机“阅读”。</p><p>例如，下图是美国Campbell公司10盎司的罐装鸡汁面包装上的UPC:</p><p><img src="http://static2.extremevision.com.cn/blogimage/upc/tu1.png" alt="图片"></p><p>你会发现，黑色条纹粗细不均，空白间隙也是粗细不均的。<br>事实上，黑色条纹有四种不同的宽度，较宽的条的宽度是最细条的宽度的两倍、三倍或者四倍。空白间隙亦然。</p><p>UPC实际上是一系列的比特，如果将一个基本单位的黑色条纹看成二进制的<code>1</code>，将一个基本单位的空白间隙看成<code>0</code>，就可以露出其“庐山真面目”:</p><p><img src="http://static2.extremevision.com.cn/blogimage/upc/tu2.png" alt="图片"></p><p>当计算机自左向右进行扫描时，它给遇到的第一个基本单位的黑条纹分配一个值为1的比特值，随后的空白间隙为0，如此下去，直到最后一个黑色条纹为止。一共会有95个比特，组成了一个UPC。对这95个比特进行分组:</p><p><img src="http://static2.extremevision.com.cn/blogimage/upc/tu3.png" alt="图片"></p><p>起初的3个比特通常是<code>101</code>，称为左边护线，最右边的3个比特也是<code>101</code>，为右边护线，它们的作用是帮助计算机扫描仪定位。<br>紧挨着左边护线，以7个比特为一组，连续6组，为左边的数字；7个比特为一组，每一组代表着数字0～9中的一个数字。<br>接着中间是5个比特的中间护线，固定为<code>01010</code>。这是一种内置式的检错码。如果扫描仪在应当找到中间护线的地方没有找到它，扫描仪就认为这不是一个UPC，以此防止错误或窜改。<br>接下来的右边的数字跟左边数字一样，7个比特一组，共6组。</p><p>有意思的是，7个比特组成一组，才代表了10个数字。照理来说，2的7次方，共128种组合，代表10个数字绰绰有余。<br>这是因为，仅有少数组合的比特值，才是有意义的。而且，左边的数字和右边的数字，组合还稍有差异。<br>映射关系如下表:</p><table><thead><tr><th style="text-align:center">数字</th><th style="text-align:center">左边的编码</th><th style="text-align:center">右边的编码</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0001101</td><td style="text-align:center">1110010</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0011001</td><td style="text-align:center">1100110</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0010011</td><td style="text-align:center">1101100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0111101</td><td style="text-align:center">1000010</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0100011</td><td style="text-align:center">1011100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0110001</td><td style="text-align:center">1001110</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0101111</td><td style="text-align:center">1010000</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0111011</td><td style="text-align:center">1000100</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0110111</td><td style="text-align:center">1001000</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0001011</td><td style="text-align:center">1110100</td></tr></tbody></table><p>左边的编码都以0开头，以1结尾，且1的个数都是“奇数”。<br>右边的编码都以1开头，以0结尾，且1的个数都是“偶数”。<br>右边的编码是左边编码的补码：凡是1的地方都换成0，凡是0的地方都换成1。<br>这不是偶然，而是故意为之。如此设计，扫描仪即使从右往左边扫描，它也知道该如何处理。</p><p>另外我们还需注意到，每个代码都仅有两组连续的值为1的比特位，这就意味着每个数字对应着条形码中的两个竖条。</p><p>如此设计还提供了一种用于检测差错和数据一致性的机制，叫做奇偶校验。<br>如果一组比特位中含有奇数个1，就称之为奇校验；如果含有偶数个1，则为偶校验。<br>进行解码时，如果发现左边的编码中出现偶数个1，则一定有错。反之亦然。这提供了一种很强的容错性，在生产中意义非凡。</p><p>如此一来，30条竖条(左边护线2条竖线，右边护线2条竖线，中间护线2条竖线，左右数字各12条竖线)，最终对应成了12个数字：</p><pre><code>0  51000  01251  7</code></pre><p>在UPC中，第一个数字(这里是0)被称为数字系统字符，不同数字代表不同大类的货物。<br>紧接着的5个数字是制造商代码。在上例中，<code>51000</code>是Campbell公司的代码。该公司产生的产品都是该代号，需要公司去申请。<br>再后面的5个数字(<code>01251</code>）是该公司的某种产品的具体编号，公司自行分配。<br>最后的数字(这里是7)称作模校验字符，这个字符提供了另外一种错误检验。</p><p>最后一位的模校验字符的计算方法如下。假设前11位数字分别用A-K符号代替:</p><pre><code>A  BCDEF  GHIJK</code></pre><p>通过公式:</p><pre><code>3 x (A + C + E + G + I + K) + (B + D + F + H + J)</code></pre><p>会得到一个数字<code>T</code>，然后对该数字<code>T</code>，从紧挨它并大于等于它的一个10的整倍数中减去它，其结果称为模校验字符。</p><p>在上例中，有：</p><pre><code>3 × (0 + 1 + 0 + 0 + 2 + 1) + (5 + 0 + 0 + 1 + 5) = 3 × 4 + 11 = 23</code></pre><p>紧挨着23并大于等于它的，还是10的整倍数，就是30, 所以最后一位数字就是<code>30－23 = 7</code>。</p><p>这就是印在外包装上并以UPC形式编码的模校验字符，这是一种冗余措施。<br>如果扫描仪计算出来的模校验结果和UPC中编码中的校验字不一致，则计算机就不能将这个UPC作为一个有效值接收。</p><p>可以看到，简简单单的UPC的设计中，至少就包含了三种校验和容错机制，设计上煞费苦心:</p><ul><li>中间护线的设计</li><li>左右边编码的奇偶校验</li><li>最后一位的模校验字符</li></ul><p>在<a href="https://en.wikipedia.org/wiki/Universal_Product_Code#Check_digit_calculation">维基百科</a>上有证明: UPC可以检测出100%的单数字错误，可以检测出90%的数字换位错误。</p><h3 id="EAN的编码解析"><a href="#EAN的编码解析" class="headerlink" title="EAN的编码解析"></a>EAN的编码解析</h3><p>UPC-A（上面所讲的UPC都是指UPC-A）有<a href="https://en.wikipedia.org/wiki/Universal_Product_Code#Variations">多种变种</a>，其中<code>UPC-E</code>和<code>EAN-13</code>比较常用。<br>UPC-E是UPC-A（12位数字）的6位数字的缩短版，由于在我国不常见，这里不再介绍。重点介绍EAN-13。</p><p>EAN-13是UPC-A的超集，可以在UPC-A的首位加入一位数字0得到。EAN-13兼容UPC-A，并且将范围扩充为原来的10倍。从EAN-13的前三位数字，还可以看出生产该商品的公司所属国。<br>EAN（European Article Number，欧洲商品条码）依照结构可以分为EAN-13和EAN-8，但我们常说的EAN一般特指EAN-13，而EAN-8是EAN-13的8位数字缩短版。</p><p>EAN-13的编码内容，由四个部分组成:</p><ul><li>国家或地区代号: 前3位(从下图中知道，第一位数字不属于条码的一部分，是“导入位”；后面解释该位如何推导)</li><li>厂商代号: 接下来4位</li><li>商品代号: 接下来5位</li><li>检查码: 最后1位，由公式计算得到(后面介绍，需要将新引入的第一位数字加入计算)</li></ul><p><img src="http://static2.extremevision.com.cn/blogimage/upc/tu4.jpg" alt="图片"></p><h4 id="编码的兼容性扩展"><a href="#编码的兼容性扩展" class="headerlink" title="编码的兼容性扩展"></a>编码的兼容性扩展</h4><p>有了UPC的基础，再来讲EAN-13就简单多了。<br>还记得讲UPC的时候，分了左边的编码和右边的编码吧。我们将左边的编码称为L-code，右边的编码称为R-code。现在加入一列: G-code。</p><table><thead><tr><th style="text-align:center">数字</th><th style="text-align:center">L-code</th><th style="text-align:center">G-code</th><th style="text-align:center">R-code</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0001101</td><td style="text-align:center">0100111</td><td style="text-align:center">1110010</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0011001</td><td style="text-align:center">0110011</td><td style="text-align:center">1100110</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0010011</td><td style="text-align:center">0011011</td><td style="text-align:center">1101100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0111101</td><td style="text-align:center">0100001</td><td style="text-align:center">1000010</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0100011</td><td style="text-align:center">0011101</td><td style="text-align:center">1011100</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0110001</td><td style="text-align:center">0111001</td><td style="text-align:center">1001110</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0101111</td><td style="text-align:center">0000101</td><td style="text-align:center">1010000</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0111011</td><td style="text-align:center">0010001</td><td style="text-align:center">1000100</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0110111</td><td style="text-align:center">0001001</td><td style="text-align:center">1001000</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0001011</td><td style="text-align:center">0010111</td><td style="text-align:center">1110100</td></tr></tbody></table><p>当第一位数字（导入位）不同时，左边的编码稍微调整，右边的编码保持不变（扫描仪依然可以判断是从左到右还是相反方向）。<br>使用L表示采用L-code的编码，R表示采用R-code的编码，G表示G-code的编码。</p><table><thead><tr><th style="text-align:center">第一位数字</th><th style="text-align:center">左边的6位数字编码</th><th style="text-align:center">右边的6位数字编码</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">LLLLLL</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">LLGLGG</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">LLGGLG</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">LLGGGL</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">LGLLGG</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">LGGLLG</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">LGGGLL</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">LGLGLG</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">LGLGGL</td><td style="text-align:center">RRRRRR</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">LGGLGL</td><td style="text-align:center">RRRRRR</td></tr></tbody></table><p>根据映射表，以第一位的导入位为1为例，<code>LLGLGG</code>表示，左边的6位数字中，1、2、4采用L-code编码，3、5、6采用G-code编码。<br>根据该对照表，从左边的6位数字编码，就可以反推出第一位数字是什么，这就是为什么第一位的导入位可以不计入条形码的一部分。<br>从第一位的导入位，也可以推出左边的6位数字该分别采用哪种编码。</p><h4 id="检查码的兼容性扩展"><a href="#检查码的兼容性扩展" class="headerlink" title="检查码的兼容性扩展"></a>检查码的兼容性扩展</h4><p>检查码的计算在UPC的基础上也很好理解。UPC的部分提到，假设前11位数字分别用A-K符号代替，现在用N表示导入位:</p><pre><code>N A BCDEF  GHIJK</code></pre><p>公式扩展为:</p><pre><code>3 x (A + C + E + G + I + K) + (N + B + D + F + H + J)</code></pre><p>由于UPC中，N始终为0，因此完美兼容。<br>举个例子：某条形码为：977167121601X（X为校验码），计算出X。</p><ul><li>7+1+7+2+6+1=24</li><li>24×3=72</li><li>9+7+6+1+1+0=24</li><li>72+24=96</li><li>100-96=4</li><li>所以最后校验码X=4。此条形码为9771671216014。</li></ul><p>可以看出，当<code>导入位 = 0</code>时（等同UPC），不管编码还是检查码，EAN-13完全兼容UPC，条形码不需要更改。</p><h4 id="EAN前三位与国家和地区的映射关系"><a href="#EAN前三位与国家和地区的映射关系" class="headerlink" title="EAN前三位与国家和地区的映射关系"></a>EAN前三位与国家和地区的映射关系</h4><table><thead><tr><th style="text-align:left">前三位数字</th><th style="text-align:left">国家或地区</th></tr></thead><tbody><tr><td style="text-align:left">690～699</td><td style="text-align:left">中国</td></tr><tr><td style="text-align:left">471</td><td style="text-align:left">中国台湾</td></tr><tr><td style="text-align:left">489</td><td style="text-align:left">中国香港</td></tr><tr><td style="text-align:left">958</td><td style="text-align:left">中国澳门</td></tr><tr><td style="text-align:left">450～459  490～499</td><td style="text-align:left">日本</td></tr><tr><td style="text-align:left">880</td><td style="text-align:left">韩国</td></tr><tr><td style="text-align:left">885</td><td style="text-align:left">泰国</td></tr><tr><td style="text-align:left">500～509</td><td style="text-align:left">英国</td></tr><tr><td style="text-align:left">000～019  030～039  060～139</td><td style="text-align:left">美国</td></tr><tr><td style="text-align:left">300～379</td><td style="text-align:left">法国</td></tr><tr><td style="text-align:left">400～440</td><td style="text-align:left">德国</td></tr><tr><td style="text-align:left">978～979</td><td style="text-align:left"><a href="http://appsbarcode.com/ISBN.php">图书ISBN</a></td></tr><tr><td style="text-align:left">977</td><td style="text-align:left"><a href="http://appsbarcode.com/ISSN.php">期刊ISSN</a></td></tr></tbody></table><h3 id="ISBN是EAN-13的子集"><a href="#ISBN是EAN-13的子集" class="headerlink" title="ISBN是EAN-13的子集"></a>ISBN是EAN-13的子集</h3><p>ISBN（International Standard Book Number，国际标准书号）是非期刊书籍上的条形码，其实只是EAN-13的子集(只讨论现使用的ISBN-13)。前三位在<code>978～979</code>范围内。</p><p>一个ISBN有一个或一份相应的出版物与之对应。一本书的每一版或其他的变化，能够申请到一个新的ISBN。<br>新版本如果在原来旧版的基础上没有内容上太大的变动，在出版时不会得到新的ISBN。<br>当一本书同时有平装本与精装本出版时，平装本的国际标准书号不得用于精装本，反之亦然。</p><p>ISBN的编码由五个部位组成，且每部位是不定长的，有时候会使用<code>-</code>符号进行分割方便阅读:</p><ul><li>前三位(第一位是导入位<code>9</code>，前三位目前的范围是978～979)</li><li>出版国家或者语言代码</li><li>出版商代码</li><li>书所分配到的号码</li><li>最后一位为检查码(同EAN-13)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.amazon.cn/gp/product/B009RSXIB4/">《编码:隐匿在计算机软硬件背后的语言》</a></li><li><a href="https://en.wikipedia.org/wiki/Universal_Product_Code#Variations">维基百科:UPC变种</a></li><li><a href="https://en.wikipedia.org/wiki/International_Article_Number#Binary_encoding_of_data_digits_into_EAN-13_barcode">维基百科:EAN</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E4%B9%A6%E5%8F%B7">维基百科:ISBN</a></li><li><a href="http://www.appsbarcode.com/EAN-13.php">Andy’s Barcode World</a></li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员必读书籍清单</title>
      <link href="/posts/books-every-programmer-should-read/"/>
      <url>/posts/books-every-programmer-should-read/</url>
      <content type="html"><![CDATA[<p>StackOverflow上有人提问: 哪本最具影响力的书，是每个程序员都应该读的？最后根据网友们的投票，得到了一份<a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read?page=1&amp;tab=votes">书籍清单</a>。</p><p>我看到不少地方在推荐“程序员必读书籍”的时候，也都会引用该清单，但是它们并没有给全。<br>我按照自己的想法，将整份清单制作成表格，方便浏览。</p><p>由于根据书名进行查找时，可能会找到相似名字的书，造成误会，因此“链接”中给出了亚马逊/豆瓣的链接，方便比对作者和封面。<br>链接仅仅为了方便查看书籍信息，不保证书的价格是最便宜的。<br>不同译者翻译的书籍质量可能良莠不齐，也不保证对应版本是最好的。书籍可能会有再版，购买时以最新版为佳。</p><p>阅读该清单前，啰嗦几点:</p><ul><li>以下书籍并不适合全部阅读，要根据自己的段位、专长和兴趣有所取舍</li><li>清单有局限性，新技术比如docker(发布于2013年)、go语言(发布于2009年)都没有提及，但这些是值得去了解的</li><li>不过，不需要乱追新技术新名词，计算机基础的东西需要积累，清单中的书籍并不会过时</li><li>偏好其他技术的入门者，我推荐<a href="oreilly"><code>O&#39;Reilly</code></a>出版的翻译书籍</li></ul><p>以下是StackOverflow上的投票结果，整理自<a href="https://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read?page=1&amp;tab=votes">原贴</a>。</p><table><thead><tr><th style="text-align:left">书单</th><th style="text-align:left">中文版</th><th style="text-align:left">链接</th></tr></thead><tbody><tr><td style="text-align:left">Code Complete (2nd edition) by Steve McConnell</td><td style="text-align:left">《代码大全(第2版)》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0061XKRXA/">亚马逊</a></td></tr><tr><td style="text-align:left">The Pragmatic Programmer</td><td style="text-align:left">《程序员修炼之道》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B005UP9PJM/">亚马逊</a></td></tr><tr><td style="text-align:left">Structure and Interpretation of Computer Programs</td><td style="text-align:left">《计算机程序的构造和解释》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0011AP7RY/">亚马逊</a></td></tr><tr><td style="text-align:left">The C Programming Language by Kernighan and Ritchie</td><td style="text-align:left">《C程序设计语言》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0011425T8/">亚马逊</a></td></tr><tr><td style="text-align:left">Introduction to Algorithms by Cormen, Leiserson, Rivest &amp; Stein</td><td style="text-align:left">《算法导论》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B00AK7BYJY/">亚马逊</a></td></tr><tr><td style="text-align:left">Design Patterns by the Gang of Four</td><td style="text-align:left">《设计模式》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B001130JN8/">亚马逊</a></td></tr><tr><td style="text-align:left">Refactoring: Improving the Design of Existing Code</td><td style="text-align:left">《重构：改善既有代码的设计》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B003BY6PLK/">亚马逊</a></td></tr><tr><td style="text-align:left">The Mythical Man Month</td><td style="text-align:left">《人月神话》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0011C2P7W/">亚马逊</a></td></tr><tr><td style="text-align:left">The Art of Computer Programming by Donald Knuth</td><td style="text-align:left">《计算机程序设计艺术》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B00478TO44/">亚马逊</a></td></tr><tr><td style="text-align:left">Compilers: Principles, Techniques and Tools <br>by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</td><td style="text-align:left">《编译原理》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B001NGO85I/">亚马逊</a></td></tr><tr><td style="text-align:left">Gödel, Escher, Bach by Douglas Hofstadter</td><td style="text-align:left">《哥德尔、艾舍尔、巴赫书：集异璧之大成》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0049MPCAS/">亚马逊</a></td></tr><tr><td style="text-align:left">Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin</td><td style="text-align:left">《代码整洁之道》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0031M9GHC/">亚马逊</a></td></tr><tr><td style="text-align:left">Effective C++</td><td style="text-align:left">《Effective C++》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B004G72P24/">亚马逊</a></td></tr><tr><td style="text-align:left">More Effective C++</td><td style="text-align:left">《More Effective C++》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B004IP8BD6/">亚马逊</a></td></tr><tr><td style="text-align:left">CODE by Charles Petzold</td><td style="text-align:left">《编码:隐匿在计算机软硬件背后的语言》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B009RSXIB4/">亚马逊</a></td></tr><tr><td style="text-align:left">Programming Pearls by Jon Bentley</td><td style="text-align:left">《编程珠玑》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B001GNBZFE/">亚马逊</a></td></tr><tr><td style="text-align:left">Working Effectively with Legacy Code by Michael C. Feathers</td><td style="text-align:left">《修改代码的艺术》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B00KMJ2Q1U/">亚马逊</a></td></tr><tr><td style="text-align:left">Peopleware by Demarco and Lister</td><td style="text-align:left">《人件集》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B005YWYHLW/">亚马逊</a></td></tr><tr><td style="text-align:left">Coders at Work by Peter Seibel</td><td style="text-align:left">《编程人生》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B004GCCAGK/">亚马逊</a></td></tr><tr><td style="text-align:left">Surely You’re Joking, Mr. Feynman!</td><td style="text-align:left">《别闹了，费曼先生！》</td><td style="text-align:left"><a href="https://book.douban.com/subject/1037602/">豆瓣</a></td></tr><tr><td style="text-align:left">Effective Java 2nd edition</td><td style="text-align:left">《Effective Java中文版》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B001PTGR52/">亚马逊</a></td></tr><tr><td style="text-align:left">Patterns of Enterprise Application Architecture by Martin Fowler</td><td style="text-align:left">《 企业应用架构模式》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B003LBSRDM/">亚马逊</a></td></tr><tr><td style="text-align:left">The Little Schemer</td><td style="text-align:left">《The Little Schemer：递归与函数式的奥妙》</td><td style="text-align:left"><a href="https://book.douban.com/subject/27080946/">豆瓣</a></td></tr><tr><td style="text-align:left">The Seasoned Schemer</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1726083/">豆瓣</a></td></tr><tr><td style="text-align:left">Why’s (Poignant) Guide to Ruby</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/1512212938/">亚马逊</a></td></tr><tr><td style="text-align:left">The Inmates Are Running The Asylum: <br>Why High Tech Products Drive Us Crazy and How to Restore the Sanity</td><td style="text-align:left">《交互设计之路:让高科技产品回归人性》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00114AM84/">亚马逊</a></td></tr><tr><td style="text-align:left">The Art of Unix Programming</td><td style="text-align:left">《Unix编程艺术》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B004GLIX6W/">亚马逊</a></td></tr><tr><td style="text-align:left">Test-Driven Development: By Example by Kent Beck</td><td style="text-align:left">《测试驱动开发》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B00EYV9KLG/">亚马逊</a></td></tr><tr><td style="text-align:left">Practices of an Agile Developer</td><td style="text-align:left">《高效程序员的45个习惯：敏捷开发修炼之道》</td><td style="text-align:left"><a href="http://www.amazon.cn/gp/product/B0033WSFAO/">亚马逊</a></td></tr><tr><td style="text-align:left">Don’t Make Me Think</td><td style="text-align:left">《点石成金:访客至上的网页设计秘笈》</td><td style="text-align:left"><a href="https://www.amazon.cn/gp/product/B0011BTJV8/">亚马逊</a></td></tr><tr><td style="text-align:left">Agile Software Development, Principles, Patterns, and Practices <br>by Robert C. Martin</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0135974445/">亚马逊</a></td></tr><tr><td style="text-align:left">Domain Driven Designs by Eric Evans</td><td style="text-align:left">《领域驱动设计:软件核心复杂性应对之道》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B01GZ6T12K/">亚马逊</a></td></tr><tr><td style="text-align:left">The Design of Everyday Things by Donald Norman</td><td style="text-align:left">《设计心理学》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B01FQAQ2VE/">亚马逊</a></td></tr><tr><td style="text-align:left">Modern C++ Design by Andrei Alexandrescu</td><td style="text-align:left">《C++设计新思维》</td><td style="text-align:left"><a href="https://book.douban.com/subject/1119904/">豆瓣</a></td></tr><tr><td style="text-align:left">Best Software Writing I by Joel Spolsky</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/4798115819/">亚马逊</a></td></tr><tr><td style="text-align:left">The Practice of Programming by Kernighan and Pike</td><td style="text-align:left">《程序设计实践》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B0198OPL16/">亚马逊</a></td></tr><tr><td style="text-align:left">Pragmatic Thinking and Learning: Refactor Your Wetware by Andy Hunt</td><td style="text-align:left">《程序员思维修炼》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00QT2TS6U/">亚马逊</a></td></tr><tr><td style="text-align:left">Software Estimation: Demystifying the Black Art by Steve McConnel</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0735605351/">亚马逊</a></td></tr><tr><td style="text-align:left">The Passionate Programmer (My Job Went To India) by Chad Fowler</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/1934356344/">亚马逊</a></td></tr><tr><td style="text-align:left">Hackers: Heroes of the Computer Revolution</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B003PDMKIY/">亚马逊</a></td></tr><tr><td style="text-align:left">Algorithms + Data Structures = Programs</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/3540606769/">亚马逊</a></td></tr><tr><td style="text-align:left">Writing Solid Code</td><td style="text-align:left">《编程精粹》</td><td style="text-align:left"><a href="https://book.douban.com/subject/3406939/">豆瓣</a></td></tr><tr><td style="text-align:left">JavaScript - The Good Parts</td><td style="text-align:left">《JavaScript语言精粹》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B0097CON2S/">亚马逊</a></td></tr><tr><td style="text-align:left">Getting Real by 37 Signals</td><td style="text-align:left">《Getting Real》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0578012812/">亚马逊</a></td></tr><tr><td style="text-align:left">Foundations of Programming by Karl Seguin</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="http://openmymind.net/FoundationsOfProgramming.pdf">电子版</a></td></tr><tr><td style="text-align:left">Computer Graphics: Principles and Practice in C (2nd Edition)</td><td style="text-align:left">计算机图形学原理及实践:C语言描述(第2版)</td><td style="text-align:left"><a href="https://book.douban.com/subject/1230412/">豆瓣</a></td></tr><tr><td style="text-align:left">Thinking in Java by Bruce Eckel</td><td style="text-align:left">《Java编程思想》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B0011F7WU4/">亚马逊</a></td></tr><tr><td style="text-align:left">The Elements of Computing Systems</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0262640686/">亚马逊</a></td></tr><tr><td style="text-align:left">Refactoring to Patterns by Joshua Kerievsky</td><td style="text-align:left">《重构与模式》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00A9YD7A2/">亚马逊</a></td></tr><tr><td style="text-align:left">Modern Operating Systems by Andrew S. Tanenbaum</td><td style="text-align:left">《现代操作系统》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B0744TZHXL/">亚马逊</a></td></tr><tr><td style="text-align:left">The Annotated Turing</td><td style="text-align:left">《图灵的秘密:他的生平、思想及论文解读》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00AAQXKXS/">亚马逊</a></td></tr><tr><td style="text-align:left">Things That Make Us Smart by Donald Norman</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0201626950/">亚马逊</a></td></tr><tr><td style="text-align:left">The Timeless Way of Building by Christopher Alexander</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0195024028/">亚马逊</a></td></tr><tr><td style="text-align:left">The Deadline: A Novel About Project Management by Tom DeMarco</td><td style="text-align:left">《最后期限》</td><td style="text-align:left"><a href="https://book.douban.com/subject/1231972/">豆瓣</a></td></tr><tr><td style="text-align:left">The C++ Programming Language (3rd edition) by Stroustrup</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/2696025/">豆瓣</a></td></tr><tr><td style="text-align:left">Patterns of Enterprise Application Architecture</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1229954/">豆瓣</a></td></tr><tr><td style="text-align:left">Computer Systems - A Programmer’s Perspective</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/26344642/">豆瓣</a></td></tr><tr><td style="text-align:left">Agile Principles, Patterns, and Practices in C# by Robert C. Martin</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1815898/">豆瓣</a></td></tr><tr><td style="text-align:left">Growing Object-Oriented Software, Guided by Tests</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/4156589/">豆瓣</a></td></tr><tr><td style="text-align:left">Framework Design Guidelines by Brad Abrams</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/3267575/">豆瓣</a></td></tr><tr><td style="text-align:left">Object Thinking by Dr. David West</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1760406/">豆瓣</a></td></tr><tr><td style="text-align:left">Advanced Programming in the UNIX Environment by W. Richard Stevens</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/11626789/">豆瓣</a></td></tr><tr><td style="text-align:left">Hackers and Painters: Big Ideas from the Computer Age</td><td style="text-align:left">《黑客与画家》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B004WHZGZQ/">亚马逊</a></td></tr><tr><td style="text-align:left">The Soul of a New Machine by Tracy Kidder</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1874018/">豆瓣</a></td></tr><tr><td style="text-align:left">CLR via C# by Jeffrey Richter</td><td style="text-align:left">《CLR via C#（第4版）》</td><td style="text-align:left"><a href="https://book.douban.com/subject/26285940/">豆瓣</a></td></tr><tr><td style="text-align:left">The Timeless Way of Building by Christopher Alexander</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1916068/">豆瓣</a></td></tr><tr><td style="text-align:left">Design Patterns in C# by Steve Metsker</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1610292/">豆瓣</a></td></tr><tr><td style="text-align:left">Zen and the Art of Motorcycle Maintenance by Robert M. Pirsig</td><td style="text-align:left">《禅与摩托车维修艺术》</td><td style="text-align:left"><a href="https://book.douban.com/subject/6811366/">豆瓣</a></td></tr><tr><td style="text-align:left">About Face - The Essentials of Interaction Design</td><td style="text-align:left">《About Face 4: 交互设计精髓》</td><td style="text-align:left"><a href="https://book.douban.com/subject/26642302/">豆瓣</a></td></tr><tr><td style="text-align:left">Here Comes Everybody: The Power of Organizing Without Organizations <br>by Clay Shirky</td><td style="text-align:left">《人人时代》</td><td style="text-align:left"><a href="https://book.douban.com/subject/11599407/">豆瓣</a></td></tr><tr><td style="text-align:left">The Tao of Programming</td><td style="text-align:left">《程序设计之道》</td><td style="text-align:left"><a href="https://book.douban.com/subject/1763714/">豆瓣</a></td></tr><tr><td style="text-align:left">Computational Beauty of Nature</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1458241/">豆瓣</a></td></tr><tr><td style="text-align:left">Object-Oriented Analysis and Design with Applications by Grady Booch</td><td style="text-align:left">《面向对象分析与设计(第3版)》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B01GE1UYAE/">亚马逊</a></td></tr><tr><td style="text-align:left">Effective Java by Joshua Bloch</td><td style="text-align:left">《Effective Java中文版》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B001PTGR52/">亚马逊</a></td></tr><tr><td style="text-align:left">Computability by N. J. Cutland</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0521294657/">亚马逊</a></td></tr><tr><td style="text-align:left">Masterminds of Programming</td><td style="text-align:left">《编程大师智慧:与主流编程语言创造者的对话》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00451BP72/">亚马逊</a></td></tr><tr><td style="text-align:left">The Tao Te Ching</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/0486297926/">亚马逊</a></td></tr><tr><td style="text-align:left">The Productive Programmer</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/3073403/">豆瓣</a></td></tr><tr><td style="text-align:left">The Art of Deception by Kevin Mitnick</td><td style="text-align:left">《反欺骗的艺术:世界传奇黑客的经历分享》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00MXLI844/">亚马逊</a></td></tr><tr><td style="text-align:left">The Career Programmer: Guerilla Tactics for an Imperfect World <br>by Christopher Duncan</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/1590596242/">亚马逊</a></td></tr><tr><td style="text-align:left">Paradigms of Artificial Intelligence Programming: Case studies in Common Lisp</td><td style="text-align:left">《人工智能编程范式》</td><td style="text-align:left"><a href="https://book.douban.com/subject/1754619/">豆瓣</a></td></tr><tr><td style="text-align:left">Masters of Doom</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1438119/">豆瓣</a></td></tr><tr><td style="text-align:left">Pragmatic Unit Testing in C# with NUnit <br>by Andy Hunt and Dave Thomas with Matt Hargett</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/2751281/">豆瓣</a></td></tr><tr><td style="text-align:left">How To Solve It by George Polya</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/10551502/">豆瓣</a></td></tr><tr><td style="text-align:left">The Alchemist by Paulo Coelho</td><td style="text-align:left">《牧羊少年奇幻之旅》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B00200LO6C/">亚马逊</a></td></tr><tr><td style="text-align:left">Writing Secure Code (2nd Edition) by Michael Howard</td><td style="text-align:left">未找到</td><td style="text-align:left"><a href="https://book.douban.com/subject/1775982/">豆瓣</a></td></tr><tr><td style="text-align:left">Rework by Jason Freid and DHH</td><td style="text-align:left">《重来:更为简单有效的商业思维》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B0048EKQS0/">亚马逊</a></td></tr><tr><td style="text-align:left">JUnit in Action</td><td style="text-align:left">《JUnit实战》</td><td style="text-align:left"><a href="https://www.amazon.cn/dp/B007NDAPHK/">亚马逊</a></td></tr></tbody></table><h3 id="补充读书清单"><a href="#补充读书清单" class="headerlink" title="补充读书清单"></a>补充读书清单</h3><ul><li><a href="http://lucida.me/blog/developer-reading-list/">lucida的博客</a></li><li><a href="http://blog.jobbole.com/5886/">伯乐在线的清单1</a></li><li><a href="https://github.com/jobbole/awesome-programming-books">伯乐在线的清单2</a></li></ul>]]></content>
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Emoji的编码以及常见问题处理</title>
      <link href="/posts/emoji-encoding/"/>
      <url>/posts/emoji-encoding/</url>
      <content type="html"><![CDATA[<p>我在<a href="https://www.huxiu.com/article/163386.html">虎嗅上</a>看过一篇关于Emoji的趣闻, 特别有意思, 在这里跟大家分享一下。里面提到了Emoji是怎么诞生的。</p><blockquote><p>1999年前后，日本一个名叫栗田穰崇的年轻人，和许多直男一样， 给女友发的短信经常会被误解。比如，“知道了”被解读成“生气了”、“不耐烦了”，随后引发冷战。 于是少年栗田想：“如果能在文字里插入一些表情符号来表达感情，大家应该会需要吧！”<br>原始的Emoji就这么诞生了。</p></blockquote><p>Emoji极大地丰富了我们的生活和通讯交流。Emoji诞生自程序员，但反过来对程序员也造成过一些困扰。<br>尤其对于面向C端的产品开发者, 用户越来越习惯于输入Emoji, 因此处理字符时遇到Emoji也只会越来越频繁。</p><h3 id="Emoji的编码"><a href="#Emoji的编码" class="headerlink" title="Emoji的编码"></a>Emoji的编码</h3><p>Emoji字符是Unicode字符集中一部分. 特定形象的Emoji表情符号对应到特定的Unicode字节。<br>常见的Emoji表情符号在Unicode字符集中的范围和具体的字节映射关系, 可通过<a href="http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols">Emoji Unicode Tables</a>查看到。</p><p>有意思的是, 在<a href="http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols">Emoji Unicode Tables</a>表中，还给出了同一个Emoji表情在不同系统中的字体(是字体没错, Emoji的样式可通过字体文件改变)。</p><p><img src="http://static.extremevision.com.cn/blogs/static/python_emoji_1.png" alt="image"></p><p>关于Emoji的最权威资料, 可以在<a href="http://unicode.org/emoji/charts/">Unicode® Emoji Charts</a>上查阅到。<br>截止我写这篇文章的时刻, Emoji Charts 的最新版本是v3.0, v4.0还只是处于Beta阶段。</p><p>题外话补充一点: Unicode是一种字符编码方法，它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。<br>我们所知道的UTF-8、UTF-16等编码, 是对Unicode的不同实现方式。<br>如果要深入了解更多关于ASCII、Unicode、UTF-8、gb2312、gbk等编码的相关知识，在这里强烈推荐几篇文章，讲得非常好。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a></li><li><a href="http://pcedu.pconline.com.cn/empolder/gj/other/0505/616631_all.html">程序员趣味读物：谈谈Unicode编码</a></li></ul><h3 id="一些特殊的Emoji"><a href="#一些特殊的Emoji" class="headerlink" title="一些特殊的Emoji"></a>一些特殊的Emoji</h3><p>在众多Emoji中, 有一些特殊的Emoji 并没有显示的样式, 只是起到了控制的作用。这些控制型的Emoji 与基础Emoji 出现在一起, 可以展示更多的样式。</p><p>比如 “变量选择器-15”(VARIATION SELECTOR-15, 简写VS-15): <code>&lt;U+FE0E&gt;</code>, 作用是让基础Emoji 变成更接近文本样式(text-style);<br>而 “变量选择器-16”(VARIATION SELECTOR-16, 简写VS-16): <code>&lt;U+FE0F&gt;</code>, 作用则是让基础Emoji 变成更接近Emoji样式(emoji-style).</p><p>VS-15 和 VS-16 加在基础Emoji字符的后面, 可以起到控制作用(前提是必须系统支持, 否则会被忽略)。</p><p><img src="http://static.extremevision.com.cn/blogs/static/python_emoji_vs_wiki.png" alt="image"></p><p>用一段Python代码来演示该例子:</p><pre><code># -*- coding: utf-8 -*-# more info to see https://en.wikipedia.org/wiki/Emoji# 符号分别是上图(截图自wiki)中的符号, 最后再加上一个“狗”的Emojisample_list = [u&apos;\u2139&apos;, u&apos;\u231B&apos;, u&apos;\u26A0&apos;, u&apos;\u2712&apos;, u&apos;\u2764&apos;, u&apos;\U0001F004&apos;, u&apos;\U0001F21A&apos;, u&apos;\U0001f436&apos;, ]# 输出原样式for code in sample_list:    print code,printprint &apos;-&apos; * 20# 后面加上VS-15for code in sample_list:    print (code + u&apos;\uFE0E&apos;),printprint &apos;-&apos; * 20# 后面加上VS-16for code in sample_list:    print (code + u&apos;\uFE0F&apos;),</code></pre><p>其输出如下图, 第一行是原样式，第二行是加上VS-15后的样式，第三行是加上VS-16后的样式:</p><p><img src="http://static.extremevision.com.cn/blogs/static/python_emoji_vs.png" alt="image"></p><p>另外, 还有一些控制型的Emoji, 可以对人体肤色进行改变，改变对象仅限于”表示人身体部位的Emoji”.<br>它们分别是: <code>&lt;U+1F3FB&gt;</code> – <code>&lt;U+1F3FF&gt;</code> 共五个, 分别简称为: FITZ-1-2, FITZ-3, FITZ-4, FITZ-5, FITZ-6.</p><p><img src="http://static.extremevision.com.cn/blogs/static/python_emoji_humanskin_wiki.png" alt="image"></p><p>还有一个特殊的控制符: <code>&lt;U+200D&gt;</code> (ZERO WIDTH JOINER, 简写ZWJ), 起到了连接Emoji的作用, 从而将多个Emoji变成一个Emoji来显示. 同样，前提是必须系统支持, 否则会被忽略.</p><p>使用Python代码演示 <code>FITZ-*</code> 和 <code>ZWJ</code>:</p><pre><code># -*- coding: utf-8 -*-# more info to see https://en.wikipedia.org/wiki/Emoji# man_list 分别是: 男孩  女孩  男人  女人man_list = [u&apos;\U0001F466&apos;, u&apos;\U0001F467&apos;, u&apos;\U0001F468&apos;, u&apos;\U0001F469&apos;]# skin_color_list 分别是: 空字符串,表示默认  白种人 --&gt;(不断加深肤色)  黑种人skin_color_list = [&apos;&apos;, u&apos;\U0001F3FB&apos;, u&apos;\U0001F3FC&apos;, u&apos;\U0001F3FD&apos;, u&apos;\U0001F3FE&apos;, u&apos;\U0001F3FF&apos;, ]for man in man_list:    for color in skin_color_list:        print (man + color),    print    print &apos;-&apos; * 20# Emoji的连接符&lt;U+200D&gt;  (英文名为: ZERO WIDTH JOINER, 简写ZWJ )# 如果系统支持: 连接(男人 + ZWJ + 女人 + ZWJ + 女孩)print u&apos;\U0001F468&apos; + u&apos;\u200D&apos; + u&apos;\U0001F469&apos; + u&apos;\u200D&apos; + u&apos;\U0001F467&apos;# 如果系统不支持: 连接(狗 + ZWJ + 猫 + ZWJ + 老鼠)print u&apos;\U0001f436&apos; + u&apos;\u200D&apos; + u&apos;\U0001f431&apos; + u&apos;\u200D&apos; + u&apos;\U0001f42d&apos;</code></pre><p>其输出如下图:</p><p><img src="http://static.extremevision.com.cn/blogs/static/python_emoji_humanskin.png" alt="image"></p><p>以上内容参考自<a href="https://en.wikipedia.org/wiki/Emoji">维基百科</a></p><p>对Emoji 的介绍到该小节结束, 下面内容是一些关于实际中可能遇到的技术问题的解决方法。</p><h3 id="MySQL存储Emoji"><a href="#MySQL存储Emoji" class="headerlink" title="MySQL存储Emoji"></a>MySQL存储Emoji</h3><p>使用MySQL存储Emoji, 只需要数据表的字符集为<code>utf8mb4</code>即可, 即<code>CHARSET=utf8mb4</code>.</p><p>如果想要知道你的MySQL数据库是否支持<code>utf8mb4</code>编码, 可通过<code>show charset;</code> 输出当前安装的MySQL所支持的所有字符集, 查看输出中是否包含有<code>utf8mb4</code>.</p><p>另外, 有一些比较老的业务, 可能一开始设计时没考虑到需要支持Emoji, 那就需要修改数据库或数据表的字符集.</p><pre><code>查看MySQL说支持的所有字符集mysql&gt; show charset;查看某张表当前的字符集mysql&gt; show create table &lt;table_name&gt;;创建默认字符集为utf8mb4的数据库.在该数据库中,如果创建表时是不指明字符集,则默认utf8mb4.mysql&gt; create database default charset utf8mb4;创建字符集为utf8mb4的表, 数据库的默认字符集非utf8mb4也没问题.mysql&gt; create table `&lt;table_name&gt;` (Column定义, Column定义, ...) DEFAULT CHARSET=utf8mb4;修改已存在的数据库的字符集mysql&gt; alter database &lt;db_name&gt; default charset = utf8mb4;修改已存在的表的字符集mysql&gt; alter table &lt;table_name&gt; default charset = utf8mb4;</code></pre><h3 id="使用正则表达式匹配Emoji"><a href="#使用正则表达式匹配Emoji" class="headerlink" title="使用正则表达式匹配Emoji"></a>使用正则表达式匹配Emoji</h3><p>很可惜, Emoji的范围并没有明确的定义。正如上面提到了，Emoji Charts目前最新版本是v3.0， 未来Emoji的范围还会不断扩大。而且Emoji 在Unicode的分配中并不是连续的区间。</p><p>所以, 在这里我只能给出一个可行的匹配区间, 尽可能涵盖了基本常见的Emoj。<br>该匹配区间中会包含一些未定义的字符, 可能在某些系统会有定义，但是在另外的系统中并没有定义。毕竟Emoji是商业的产物。</p><p>该匹配规则区间参考了<a href="http://unicode.org/Public/emoji/3.0/emoji-data.txt">emoji-data.txt</a> 和 <a href="http://unicode.org/reports/tr51/index.html#emoji_data">Unicode® Technical Report #51</a>, 如下:</p><pre><code>&lt;U+1F300&gt; - &lt;U+1F5FF&gt;      # symbols &amp; pictographs&lt;U+1F600&gt; - &lt;U+1F64F&gt;      # emoticons&lt;U+1F680&gt; - &lt;U+1F6FF&gt;      # transport &amp; map symbols&lt;U+2600&gt;  - &lt;U+2B55&gt;       # other</code></pre><p>下面使用Python代码来演示如何使用正则表达式替换(或找出)字符串中的Emoji:</p><pre><code># -*- coding: utf-8 -*-import retry:    # Wide UCS-4 build    myre = re.compile(u&apos;[&apos;        u&apos;\U0001F300-\U0001F64F&apos;        u&apos;\U0001F680-\U0001F6FF&apos;        u&apos;\u2600-\u2B55]+&apos;,        re.UNICODE)except re.error:    # Narrow UCS-2 build    myre = re.compile(u&apos;(&apos;        u&apos;\ud83c[\udf00-\udfff]|&apos;        u&apos;\ud83d[\udc00-\ude4f\ude80-\udeff]|&apos;        u&apos;[\u2600-\u2B55])+&apos;,        re.UNICODE)sss = u&apos;I have a dog \U0001f436 . You have a cat \U0001f431 ! I smile \U0001f601 to you!&apos;print myre.sub(&apos;[Emoji]&apos;, sss)  # 替换字符串中的Emojiprint myre.findall(sss)         # 找出字符串中的Emoji</code></pre><p>输出如下:</p><pre><code>I have a dog [Emoji] . You have a cat [Emoji] ! I smile [Emoji] to you![u&apos;\U0001f436&apos;, u&apos;\U0001f431&apos;, u&apos;\U0001f601&apos;]</code></pre><p>上面例子中, 之所以使用<code>try...except...</code>来处理代码, 是考虑到 UCS-2 (Narrow UCS-2 build) 和 UCS-4 (Wide UCS-4 build) 的区别.<br>该Demo例子参考了<a href="http://stackoverflow.com/questions/26568722/remove-unicode-emoji-using-re-in-python">stackoverflow</a>上的精彩回答, 解答了我对此的困惑。</p><p>关于UCS-2和UCS-4的区别, 在上面提到的扩展阅读<a href="http://pcedu.pconline.com.cn/empolder/gj/other/0505/616631_all.html">程序员趣味读物：谈谈Unicode编码</a>中有提到, 值得一看.</p><p>本文中使用到的示例代码，可以在<a href="https://github.com/wolfhong/blogs/tree/master/example/python_emoji">我的github</a>下载到。</p><h3 id="带有Emoji的字符串截取"><a href="#带有Emoji的字符串截取" class="headerlink" title="带有Emoji的字符串截取"></a>带有Emoji的字符串截取</h3><p>在Python、JavaScript 这类编程语言中, 一个中文字符的长度为1，但是对大部分的Emoji(并非全部), 取长度则是2。下面使用Python做演示。</p><p>以中文的”汉”字取长度为例，取长度为1:</p><pre><code>&gt;&gt;&gt;len(u&apos;汉&apos;)1</code></pre><p>而对于Emoji，以<code>&lt;U+1f436&gt;</code>(该Emoji是一只萌萌的狗)为例，取长度为2:</p><pre><code>&gt;&gt;&gt;len(u&apos;\U0001f436&apos;)2</code></pre><p>那么, 这就存在一个隐患, 在对字符串进行截断时可能从中间截断, 导致该字符显示为乱码, 甚至引发报错。</p><p>下面例子中, 对字符串进行截取时，正好从<code>&lt;U+1f436&gt;</code>的中间截断了，出现了乱码:</p><pre><code>&gt;&gt;&gt;u&apos;这是一只可爱的狗狗\U0001f436&apos;.__len__()11&gt;&gt;&gt;u&apos;这是一只可爱的狗狗\U0001f436&apos;[0:10]这是一只可爱的狗狗???</code></pre><p>实际场景中，对字符串进行截断是非常常见的需求，而且字符串往往可能是用户高度自由的输入内容, 那么包含Emoji的可能性其实是很高的。<br>一个具体的场景就是: 你正在开发了一款社交APP, 允许用户保存文字记录, 然后在应用的某个地方, 又需要显示这些文字记录的摘要，摘要只显示用户输入的前100个字符, 超出部分用省略号表示。<br>这种情况下，就不可避免的可能发生Emoji在中间被截断的问题。</p><p>解决方案也有多种:</p><ul><li>全文进行正则匹配, 去掉大部分Emoji, 但是文本长度过长的情况消耗太大, 不值得.</li><li>先截取前200个字符, 匹配去掉Emoji再截取100个字符. 貌似可行. 但如果极端条件下前200个字符都是Emoji怎么办? 管他的.</li><li>运用上面提到的扩展阅读: <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a>中提到的UTF-8的编码规则, 对截断后字符串的最后字符进行检查, 发现是截断的字符即进行剔除。该方案可行, 不过你需要自己去实现了。</li><li>允许一定概率出现乱码, 乱码就乱码吧，概率不高，不影响主要体验。将更多精力放在避免其他bug上吧。</li></ul>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emoji </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Emoji表情拼成汉字</title>
      <link href="/posts/use-zh2emoji/"/>
      <url>/posts/use-zh2emoji/</url>
      <content type="html"><![CDATA[<p>这只是一个娱乐性的实现，纯属突发奇想。</p><p>使用Emoji表情组成汉字或者简笔画，在微信、QQ的传播中甚广，就会想着要不自己也试着做出来吧.</p><p>比如下图:</p><p><img src="http://static.extremevision.com.cn/membercms/zh2emoji/beer_500.png?imageMogr2/thumbnail/400x" alt="image"></p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>一开始想到的实现方案就是: 首先将汉字转化成白底黑字的图片, 然后将图片根据灰度值映射成不同的字符打印在终端。</p><p>前者文字转图片，使用常见的绘图库非常好实现(比如python的PIL库);<br>工作量无非只是实现过程中慢慢调整排版, 以达到自己的预期效果.</p><p>后者则是简单的映射关系而已: 将图片中像素点的灰度值, 映射成某个字符; 在该实现中, 对于黑底白字的图片只有两个映射关系, 黑字对应要替换的Emoji字符, 白底对应空白.</p><p>该部分的python实现代码如下:</p><pre><code>ascii_char = list(&apos;1234567890abcd &apos;)  # 任意多个字符,灰度值的映射区间def select_ascii_char(r, g, b):    &apos;&apos;&apos; 在灰度图像中,灰度值最高为255,代表白色; 最低为0,代表黑色 &apos;&apos;&apos;    # 把RGB转为灰度值，并且返回该灰度值对应的字符标记    # &apos;RGB－灰度值&apos;转换公式如下    gray = int((19595 * r + 38469 * g + 7472 * b) &gt;&gt; 16)    # ascii_char中的一个字符所能表示的灰度值区间    unit = 256.0 / len(ascii_char)    return ascii_char[int(gray/unit)]</code></pre><p><code>select_ascii_char</code> 就实现了将一个像素点映射成一个具体的自定义字符char.</p><p>在本功能的实现中, <code>ascii_char</code>更简单, 只需要两个字符即可: 一个任意给定, 一个是空格.</p><p>因此将 <code>ascii_char</code> 换成 <code>[u&#39;❤️ &#39;, u&#39;  &#39;]</code></p><p>由于需要将图片的像素点映射到可在终端打印的字符, 终端的显示空间有限, 所以需要对图片进行缩小调整.</p><p><code>zh2emoji</code>的代码在<a href="https://github.com/wolfhong/zh2emoji">我的github上</a>有对应的代码下载, 如果你有兴趣，可以fork后实现自己想要的更多自定义功能.</p><h3 id="展示例子"><a href="#展示例子" class="headerlink" title="展示例子"></a>展示例子</h3><p>一个”茴”字我有N多种写法:</p><pre><code>print image2print(word2image(u&apos;茴&apos;), u&apos;❤️ &apos;)print image2print(word2image(u&apos;茴&apos;), u&apos;茴&apos;, width=40)</code></pre><p>输出结果如下:</p><p><img src="http://static.extremevision.com.cn/membercms/zh2emoji/emoji_500.png?imageMogr2/thumbnail/400x" alt="image"><br><img src="http://static.extremevision.com.cn/membercms/zh2emoji/chinese_500.png?imageMogr2/thumbnail/400x" alt="image"></p><p>用😂 组成”哭”字:</p><p><img src="http://static.extremevision.com.cn/membercms/zh2emoji/ku_500.png?imageMogr2/thumbnail/400x" alt="image"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>基于zh2emoji，自己实现了一个可能有点儿用的扩展: <code>demo_show_animation.py</code>.</p><p>它可以将一句话在终端依次打印出来,使用你决定的Emoji或者其他字符.</p><p>比如你试着执行 <code>python ./demo_show_animation.py 喜欢就点个赞呗</code>, 将在终端执行一段展示文字的动画, 展示的文字就是你刚才输入的话.</p><p>如果你能够坚持看到这里, 不知道你有没有想到一些有意思的玩法不? 欢迎一起参与。编程是一种乐趣，代码是将一些头脑想法实现出来的媒介；程序员写代码，就好比作家写写文字，是一种习惯。</p><p>关于Emoji的更多知识介绍，可以阅读我的另一篇正经的博客: <a href="/posts/emoji-encoding/">Emoji的编码以及常见问题的解决方法</a></p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emoji </tag>
            
            <tag> 小玩意 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac下挂载远程目录到本地</title>
      <link href="/posts/mac-sshfs/"/>
      <url>/posts/mac-sshfs/</url>
      <content type="html"><![CDATA[<p>挂载远程目录到本地，目的是希望能够跟查看本地文件一样，可以方便地浏览远程目录下的文件。</p><p>sshfs就是能够满足这项需求的程序，不仅适用于ubuntu/centos等linux系统，也同样适用于Mac。</p><p>以Mac为例，使用brew安装sshfs</p><pre><code>brew install sshfs</code></pre><p>brew是Mac下十分常见的套件管理工具, 如果你的电脑没有安装该程序, 请参考<a href="http://brew.sh/index_zh-cn.html">Homebrew</a>进行安装。</p><p>安装过程中, 你可能会遇到如下的错误:</p><pre><code>sshfs: OsxfuseRequirement unsatisfied!Error: An unsatisfied requirement failed this build.</code></pre><p><img src="http://static.extremevision.com.cn/membercms/sshfs/mac_sshfs_error01.png" alt="image01"></p><p>只需要按照提示一步一步操作即可.</p><p>先执行<code>brew cask install osxfuse</code>. 该过程实际上是去github下载安装<code>osxfuse.dmg</code>.</p><p>安装好osxfuse后，按照提示需要重启电脑(不过我试过了，不重启电脑也是可以的)。</p><p>这时候再来重新执行<code>brew install sshfs</code>即可.</p><p>安装sshfs结束后, 就可以使用<code>sshfs</code>挂载远程目录到本地：</p><pre><code>sshfs -C -o reconnect &lt;user&gt;@&lt;host&gt;:&lt;remote_dir&gt; &lt;local_dir&gt;</code></pre><p>比如,我想要将远程主机192.168.1.101上的<code>/mnt/images/</code>目录，挂载到本地<code>~/Desktop/images/</code>目录下。过程中使用root账号登陆.</p><pre><code>sshfs -C -o reconnect root@192.168.1.101:/mnt/images/ ~/Desktop/images/</code></pre><p>如果ssh不是默认的22端口,则还需要带上选项: <code>-p &lt;端口号&gt;</code></p><p>挂载到本地时, 请避免挂载在根目录，或者当前角色的主目录下, 会报错。比如如下的错误操作:</p><pre><code>mkdir ~/ImageFoldersshfs -C -o reconnect root@192.168.1.101:/mnt/images/ ~/ImageFolder/</code></pre><p>会看到错误提示:</p><pre><code>mount_osxfuse: mount point /Users/xxxx/ImageFolder is itself on a OSXFUSE volumefuse: failed to mount file system: Invalid argument</code></pre>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sudoers的深入剖析与用户权限控制</title>
      <link href="/posts/intro-sudoers/"/>
      <url>/posts/intro-sudoers/</url>
      <content type="html"><![CDATA[<p>Linux是多用户多任务的操作系统, 共享该系统的用户往往不只一个。<br>出于安全性考虑, 有必要通过<code>useradd</code>创建一些非root用户, 只让它们拥有不完全的权限; 如有必要，再来提升权限执行。</p><p>sudo就是来解决这个需求的: 这些非root用户不需要知道root的密码，就可以提权到root，执行一些root才能执行的命令。</p><p>执行<code>sudo -u &lt;用户名&gt; &lt;命令&gt;</code>, 将允许当前用户，提权到<code>&lt;用户名&gt;</code>的身份，再执行后面的<code>&lt;命令&gt;</code>, 即使<code>&lt;命令&gt;</code>原本需要root权限。<br>提权到<code>&lt;用户名&gt;</code>身份时，是以<code>&lt;用户名&gt;</code>的身份来执行命令的，因此创建的文件默认属于<code>&lt;用户名&gt;</code>用户。</p><p>因此，当userB执行如下命令时:</p><pre><code>sudo -u userA touch /tmp/belong-to-who.tmp</code></pre><p>创建的<code>/tmp/belong-to-who.tmp</code> 文件属于用户userA。</p><p>如果不带<code>-u</code>, 则默认使用root用户，而大多数时候sudo都是要提权到root的，所以<code>-u &lt;用户名&gt;</code>可以省略为:</p><pre><code>sudo &lt;命令&gt;</code></pre><p>需要注意的是: 执行sudo时输入的密码是当前用户的密码, 并非<code>&lt;用户名&gt;</code>的密码。<br><code>sudo -u &lt;用户名&gt;</code>和<code>su - &lt;用户名&gt;</code>相比:<br>前者需要输入当前用户的密码，提权到<code>&lt;用户名&gt;</code>身份执行命令后返回当前用户;<br>后者则是输入目标用户的密码，切换到目标用户。</p><h3 id="赋予用户sudo操作的权限"><a href="#赋予用户sudo操作的权限" class="headerlink" title="赋予用户sudo操作的权限"></a>赋予用户sudo操作的权限</h3><p>关于<a href="http://www.runoob.com/linux/linux-user-manage.html">Linux用户和用户组管理</a>的知识点不是本篇文章要讨论的, 如对<code>useradd</code>、 <code>usermod</code>、 <code>passwd</code>、 <code>groupadd</code>等指令生疏，可移步<a href="http://www.runoob.com/linux/linux-user-manage.html">链接</a>, 那里有详细的讲解了。<br>通过<code>useradd</code>添加的用户，并不具备sudo权限。在ubuntu/centos等系统下, 需要将用户加入admin组或者wheel组或者sudo组。</p><p>以root用户身份执行如下命令, 将用户加入wheel/admin/sudo组:</p><pre><code>usermod -a -G wheel &lt;用户名&gt;</code></pre><p>如果提示wheel组不存在, 则还需要先创建该组:</p><pre><code>groupadd wheel</code></pre><h3 id="用公式讲解-etc-sudoers的内容"><a href="#用公式讲解-etc-sudoers的内容" class="headerlink" title="用公式讲解/etc/sudoers的内容"></a>用公式讲解/etc/sudoers的内容</h3><p>sudo的权限控制可以在<code>/etc/sudoers</code>文件中查看到。</p><p>如果想要控制某个用户(或某个组用户)只能执行root权限中的一部分命令, 或者允许某些用户使用sudo时不需要输入密码,就需要对该文件有所了解。</p><p>一般来说，通过<code>cat /etc/sudoers</code>指令来查看该文件, 会看到如下几行代码:</p><pre><code>root   ALL=(ALL:ALL) ALL%wheel ALL=(ALL) ALL%sudo  ALL=(ALL:ALL) ALL</code></pre><p>对<code>/etc/sudoers</code>文件进行编辑的代码公式可以概括为:</p><pre><code>授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...</code></pre><p>凡是<code>[ ]</code>中的内容, 都能省略; 命令和命令之间用<code>,</code>号分隔;</p><p>为了方便说明, 将公式的各个部分称呼为字段1 - 字段5:</p><pre><code>授权用户/组 主机  =[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...字段1      字段2  =[(字段3)] [字段4] 字段5</code></pre><p>字段3、字段4，是可以省略的。</p><p>在上面的默认例子中, “字段1”不以<code>%</code>号开头的表示”将要授权的用户”, 比如例子中的<code>root</code>；<br>以<code>%</code>号开头的表示”将要授权的组”, 比如例子中的<code>%wheel</code>组 和 <code>%sudo</code>组。</p><p>“字段2”表示允许登录的主机, ALL表示所有; 如果该字段不为ALL,表示授权用户只能在某些机器上登录本服务器来执行sudo命令. 比如:</p><pre><code>jack mycomputer=/usr/sbin/reboot,/usr/sbin/shutdown</code></pre><p>表示: 普通用户jack在主机(或主机组)mycomputer上, 可以通过sudo执行reboot和shutdown两个命令。”字段3”和”字段4”省略。</p><p>“字段3”如果省略, 相当于<code>(root:root)</code>，表示可以通过<code>sudo</code>提权到root; 如果为<code>(ALL)</code>或者<code>(ALL:ALL)</code>, 表示能够提权到<code>(任意用户:任意用户组)</code>。</p><p>请注意，”字段3”如果没省略,必须使用<code>( )</code>双括号包含起来。这样才能区分是省略了”字段3”还是省略了”字段4”。</p><p>“字段4”的可能取值是<code>NOPASSWD:</code>。请注意NOPASSWD后面带有冒号<code>:</code>。表示执行sudo时可以不需要输入密码。比如:</p><pre><code>lucy ALL=(ALL) NOPASSWD: /bin/useradd</code></pre><p>表示: 普通用户lucy可以在任何主机上, 通过sudo执行<code>/bin/useradd</code>命令, 并且不需要输入密码.</p><p>又比如:</p><pre><code>peter ALL=(ALL) NOPASSWD: ALL</code></pre><p>表示: 普通用户peter可以在任何主机上, 通过sudo执行任何命令, 并且不需要输入密码。</p><p>“字段5”是使用逗号分开一系列命令,这些命令就是授权给用户的操作; ALL表示允许所有操作。</p><p>你可能已经注意到了, 命令都是使用绝对路径, 这是为了避免目录下有同名命令被执行，从而造成安全隐患。</p><p>如果你将授权写成如下安全性欠妥的格式:</p><pre><code>lucy ALL=(ALL) chown,chmod,useradd</code></pre><p>那么用户就有可能创建一个他自己的程序, 也命名为userad, 然后放在它的本地路径中, 如此一来他就能够使用root来执行这个”名为useradd的程序”。这是相当危险的!</p><p>命令的绝对路径可通过<code>which</code>指令查看到: 比如<code>which useradd</code>可以查看到命令<code>useradd</code>的绝对路径: <code>/usr/sbin/useradd</code></p><h3 id="公式还要扩充"><a href="#公式还要扩充" class="headerlink" title="公式还要扩充"></a>公式还要扩充</h3><p>例子1:</p><pre><code>papi ALL=(root) NOPASSWD: /bin/chown,/usr/sbin/useradd</code></pre><p>表示: 用户papi能在所有可能出现的主机上, 提权到root下执行/bin/chown, 不必输入密码; 但运行/usr/sbin/useradd 命令时需要密码.</p><p>这是因为<code>NOPASSWD:</code>只影响了其后的第一个命令: 命令1.</p><p>上面给出的公式只是简化版，完整的公式如下:</p><pre><code>授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1, [(字段3)] [字段4] 命令2, ...</code></pre><p>在具有sudo操作的用户下, 执行<code>sudo -l</code>可以查看到该用户被允许和被禁止运行的命令.</p><h3 id="通配符和取消命令"><a href="#通配符和取消命令" class="headerlink" title="通配符和取消命令"></a>通配符和取消命令</h3><p>例子2:</p><pre><code>papi ALL=/usr/sbin/*,/sbin/*,!/usr/sbin/fdisk</code></pre><p>用例子2来说明通配符<code>*</code>的用法, 以及命令前面加上<code>!</code>号表示取消该命令。</p><p>该例子的意思是: 用户papi在所有可能出现的主机上, 能够运行目录/usr/sbin和/sbin下所有的程序, 但fdisk除外.</p><h3 id="开始编辑"><a href="#开始编辑" class="headerlink" title="开始编辑"></a>开始编辑</h3><p>“你讲了这么多,但是在实践中,我去编辑/etc/sudoers文件，系统提示我没权限啊，怎么办?”</p><p>这是因为<code>/etc/sudoers</code>的内容如此敏感，以至于该文件是只读的。所以，编辑该文件前，请确认清楚你知道自己正在做什么。</p><p>强烈建议通过<code>visudo</code>命令来修改该文件，通过<code>visudo</code>修改，如果配置出错，会有提示。</p><p>不过，系统文档推荐的做法，不是直接修改<code>/etc/sudoers</code>文件，而是将修改写在<code>/etc/sudoers.d/</code>目录下的文件中。</p><p>如果使用这种方式修改sudoers，需要在<code>/etc/sudoers</code>文件的最后行，加上<code>#includedir /etc/sudoers.d</code>一行(默认已有):</p><pre><code>#includedir /etc/sudoers.d</code></pre><p>注意了，这里的指令<code>#includedir</code>是一个整体, 前面的<code>#</code>号不能丢，并非注释，也不能在<code>#</code>号后有空格。</p><p>任何在<code>/etc/sudoers.d/</code>目录下，不以<code>~</code>号结尾的文件和不包含<code>.</code>号的文件，都会被解析成<code>/etc/sudoers</code>的内容。</p><p>文档中是这么说的:</p><pre><code># This will cause sudo to read and parse any files in the /etc/sudoers.d# directory that do not end in &apos;~&apos; or contain a &apos;.&apos; character.# Note that there must be at least one file in the sudoers.d directory (this# one will do), and all files in this directory should be mode 0440.# Note also, that because sudoers contents can vary widely, no attempt is# made to add this directive to existing sudoers files on upgrade.# Finally, please note that using the visudo command is the recommended way# to update sudoers content, since it protects against many failure modes.</code></pre><h3 id="其他小知识"><a href="#其他小知识" class="headerlink" title="其他小知识"></a>其他小知识</h3><h4 id="输入密码时有反馈"><a href="#输入密码时有反馈" class="headerlink" title="输入密码时有反馈"></a>输入密码时有反馈</h4><p>当使用sudo后输入密码，并不会显示任何东西 —— 甚至连常规的星号都没有。有个办法可以解决该问题。</p><p>打开<code>/etc/sudoers</code>文件找到下述一行:</p><pre><code>Defaults        env_reset</code></pre><p>修改成:</p><pre><code>Defaults        env_reset,pwfeedback</code></pre><h4 id="修改sudo会话时间"><a href="#修改sudo会话时间" class="headerlink" title="修改sudo会话时间"></a>修改sudo会话时间</h4><p>如果你经常使用sudo 命令，你肯定注意到过当你成功输入一次密码后，可以不用再输入密码就可以运行几次sudo命令。<br>但是一段时间后，sudo 命令会再次要求你输入密码。默认是15分钟，该时间可以调整。添加<code>timestamp_timeout=分钟数</code>即可。<br>时间以分钟为单位，-1表示永不过期，但强烈不推荐。</p><p>比如我希望将时间延长到1小时，还是打开<code>/etc/sudoers</code>文件找到下述一行:</p><pre><code>Defaults        env_reset</code></pre><p>修改成:</p><pre><code>Defaults        env_reset,pwfeedback,timestamp_timeout=60</code></pre>]]></content>
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>crontab执行失败的多种原因</title>
      <link href="/posts/why-crontab-not-work-as-you-want/"/>
      <url>/posts/why-crontab-not-work-as-you-want/</url>
      <content type="html"><![CDATA[<p>crontab是Linux下执行定时任务的常见方法。<br>这里总结一下自己遇到的或者被问到的相关问题, 诸如”为什么crontab执行失败”, “为什么crontab没有执行”。</p><p>在分析之前, 我们先确认一个前提: 操作命令本身的执行并没有问题, 在shell下可正常运行;<br>不存在权限问题, 更没有参数缺少的问题。<br>也即是说，使用<code>crontab -l</code>输出该命令时，直接复制到shell中是可以正常执行的，但是在crontab中事与愿违。</p><p>在以上的前提下，可能是如下的几个原因，导致了crontab不能正常执行。</p><h3 id="crontab中包含非法字符"><a href="#crontab中包含非法字符" class="headerlink" title="crontab中包含非法字符"></a>crontab中包含非法字符</h3><p>比如这个命令:</p><pre><code>echo `date +%Y%m%d`</code></pre><p>该命令在shell下直接执行是没问题的，但是在crontab中就有问题. 原因是crontab中不能出现非法字符<code>%</code>.<br><code>%</code>字符如果没有跟在转义字符<code>\</code>之后，将会被当做换行符，第一个<code>%</code>字符之后的内容将会视为该行命令的标准输入。</p><p>通过 <code>man 5 crontab</code> 查看到该问题的说明, 如下图:<br><img src="http://static.extremevision.com.cn/membercms/crontab_error_img2.png" alt="非法字符的说明"></p><p>解决方法也很简单:</p><ul><li>既可以将命令写在另一个sh文件中,然后再来执行该文件</li><li>也可以使用<code>\</code>符号对非法字符进行转义</li></ul><h3 id="etc-crontab-与-contab-e-两种格式混淆"><a href="#etc-crontab-与-contab-e-两种格式混淆" class="headerlink" title="/etc/crontab 与 contab -e 两种格式混淆"></a>/etc/crontab 与 contab -e 两种格式混淆</h3><p>定时任务有两种编辑方法，一种是root用户下编辑/etc/crontab文件: <code>vi /etc/crontab</code>;<br>一种是在特定用户身份下(可能是root,可能非root)，执行<code>crontab -e</code> 进行编辑.</p><p>前者的格式相比于后者, 多了一个表示执行命令的“用户身份”的字段.如下图:<br><img src="http://static.extremevision.com.cn/membercms/crontab_error_img1.png" alt="前者的格式"></p><p>这很好理解, /etc/crontab 对所有用户都是同一个文件,当然需要指明是以哪个用户来执行命令了.</p><p>以 <code>echo &quot;right&quot; &gt;&gt; /tmp/output_right.txt</code> 命令为例:<br>在编辑<code>/etc/crontab</code>时需要写成:</p><pre><code>*/1 * * * * root echo &quot;right&quot; &gt;&gt; /tmp/output_right.txt</code></pre><p>在<code>crontab -e</code>的情况下则要写成:</p><pre><code>*/1 * * * * echo &quot;right&quot; &gt;&gt; /tmp/output_right.txt</code></pre><h3 id="crond服务未启动"><a href="#crond服务未启动" class="headerlink" title="crond服务未启动"></a>crond服务未启动</h3><p>这个就太好检查了, 执行<code>service crond status</code> 查看该服务的运行状态.<br>如果进程已经dead，重启一下即可:</p><pre><code>service crond start</code></pre><h3 id="标准-错误输出中包含不支持字符-比如中文"><a href="#标准-错误输出中包含不支持字符-比如中文" class="headerlink" title="标准/错误输出中包含不支持字符(比如中文)"></a>标准/错误输出中包含不支持字符(比如中文)</h3><p>这仅仅是一个可能的原因, 不同环境上的表现可能不一样, 跟操作系统支持的编码有关.</p><p>比如下面一段简单的python代码:</p><pre><code># -*- coding: utf-8 -*-print(u&apos;中文&apos;)</code></pre><p>将以上代码保存为文件demo.py. 在shell中执行 <code>python demo.py</code> 是没问题的, 但是在crontab就可能出现问题.</p><p>总之避免在日志输出中包含中文吧。</p><h3 id="缺少环境变量或者未使用绝对路径"><a href="#缺少环境变量或者未使用绝对路径" class="headerlink" title="缺少环境变量或者未使用绝对路径"></a>缺少环境变量或者未使用绝对路径</h3><p>环境变量在/etc/crontab 顶部的<code>PATH</code>中指定了。默认情况下，<code>PATH=/sbin:/bin:/usr/sbin:/usr/bin</code></p><p>假设你安装了<code>supervisorctl</code>(一个守护进程的软件)到路径<code>/usr/local/bin/supervisorctl</code>, 然后定义了每天一次的定时任务:</p><pre><code>0 1 * * * supervisorctl restart all</code></pre><p>该定时任务并不会生效。</p><p>原因在于，<code>PATH</code>中并没有将<code>/usr/local/bin</code>加入环境变量。执行<code>supervisorctl</code>时找不到该文件。<br>解决方法有：</p><ul><li>将<code>/usr/local/bin</code>加入<code>PATH</code></li><li>或者使用绝对路径 <code>0 1 * * * /usr/local/bin/supervisorctl restart all</code></li></ul>]]></content>
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>介绍Python的魔术方法 - Magic Method</title>
      <link href="/posts/intro-python-magic-method/"/>
      <url>/posts/intro-python-magic-method/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Python中，所有以<code>__</code>双下划线包起来的方法，都统称为”魔术方法”。比如我们接触最多的<code>__init__</code>.</p><p>有些魔术方法,我们可能以后一辈子都不会再遇到了,这里也就只是简单介绍下;</p><p>而有些魔术方法,巧妙使用它可以构造出非常优美的代码,比如将复杂的逻辑封装成简单的API。</p><p>本文编辑的思路借鉴自Rafe Kettler的这篇博客: <a href="http://www.rafekettler.com/magicmethods.html">A Guide to Python Magic Methods</a>，并补充了一些代码示例。</p><p>介绍的顺序大概是：常见的先介绍，越少见的越靠后讲。</p><p>本文中用到的代码示例，可以在我的<a href="https://github.com/wolfhong/blogs/tree/master/example/python_magic_method">github</a>下载到。</p><h2 id="构造和初始化"><a href="#构造和初始化" class="headerlink" title="构造和初始化"></a>构造和初始化</h2><p><code>__init__</code>我们很熟悉了,它在对象初始化的时候调用,我们一般将它理解为”构造函数”.</p><p>实际上, 当我们调用<code>x = SomeClass()</code>的时候调用,<code>__init__</code>并不是第一个执行的, <code>__new__</code>才是。所以准确来说,是<code>__new__</code>和<code>__init__</code>共同构成了”构造函数”.</p><p><code>__new__</code>是用来创建类并返回这个类的实例, 而<code>__init__</code>只是将传入的参数来初始化该实例.</p><p><code>__new__</code>在创建一个实例的过程中必定会被调用,但<code>__init__</code>就不一定，比如通过<code>pickle.load</code>的方式反序列化一个实例时就不会调用<code>__init__</code>。</p><p><code>__new__</code>方法总是需要返回该类的一个实例，而<code>__init__</code>不能返回除了None的任何值。比如下面例子:</p><pre><code>class Foo(object):    def __init__(self):        print &apos;foo __init__&apos;        return None  # 必须返回None,否则抛TypeError    def __del__(self):        print &apos;foo __del__&apos;</code></pre><p>实际中,你很少会用到<code>__new__</code>，除非你希望能够控制类的创建。<br>如果要讲解<code>__new__</code>，往往需要牵扯到<code>metaclass</code>(元类)的介绍。<br>如果你有兴趣深入,可以参考我的另一篇博客: <a href="/posts/intro-python-metaclass/">理解Python的metaclass</a></p><p>对于<code>__new__</code>的重载，<a href="https://www.python.org/download/releases/2.2/descrintro/#__new__">Python文档中</a>也有了详细的介绍。</p><p>在对象的生命周期结束时, <code>__del__</code>会被调用,可以将<code>__del__</code>理解为”析构函数”.<br><code>__del__</code>定义的是当一个对象进行垃圾回收时候的行为。</p><p>有一点容易被人误解, 实际上，<code>x.__del__()</code> 并不是对于<code>del x</code>的实现,但是往往执行<code>del x</code>时会调用<code>x.__del__()</code>.</p><p>怎么来理解这句话呢? 继续用上面的Foo类的代码为例:</p><pre><code>foo = Foo()foo.__del__()print foodel fooprint foo  # NameError, foo is not defined</code></pre><p>如果调用了<code>foo.__del__()</code>，对象本身仍然存在. 但是调用了<code>del foo</code>, 就再也没有foo这个对象了.</p><p>请注意，如果解释器退出的时候对象还存在，就不能保证 <code>__del__</code> 被确切的执行了。所以<code>__del__</code>并不能替代良好的编程习惯。<br>比如，在处理socket时，及时关闭结束的连接。</p><h2 id="属性访问控制"><a href="#属性访问控制" class="headerlink" title="属性访问控制"></a>属性访问控制</h2><p>总有人要吐槽Python缺少对于类的封装,比如希望Python能够定义私有属性，然后提供公共可访问的getter和 setter。Python其实可以通过魔术方法来实现封装。</p><p><code>__getattr__(self, name)</code></p><p>该方法定义了你试图访问一个不存在的属性时的行为。因此，重载该方法可以实现捕获错误拼写然后进行重定向, 或者对一些废弃的属性进行警告。</p><p><code>__setattr__(self, name, value)</code></p><p><code>__setattr__</code> 是实现封装的解决方案，它定义了你对属性进行赋值和修改操作时的行为。<br>不管对象的某个属性是否存在,它都允许你为该属性进行赋值,因此你可以为属性的值进行自定义操作。有一点需要注意，实现<code>__setattr__</code>时要避免”无限递归”的错误，下面的代码示例中会提到。</p><p><code>__delattr__(self, name)</code></p><p><code>__delattr__</code>与<code>__setattr__</code>很像，只是它定义的是你删除属性时的行为。实现<code>__delattr__</code>是同时要避免”无限递归”的错误。</p><p><code>__getattribute__(self, name)</code></p><p><code>__getattribute__</code>定义了你的属性被访问时的行为，相比较，<code>__getattr__</code>只有该属性不存在时才会起作用。<br>因此，在支持<code>__getattribute__</code>的Python版本,调用<code>__getattr__</code>前必定会调用 <code>__getattribute__</code>。<code>__getattribute__</code>同样要避免”无限递归”的错误。<br>需要提醒的是，最好不要尝试去实现<code>__getattribute__</code>,因为很少见到这种做法，而且很容易出bug。</p><p>例子说明<code>__setattr__</code>的无限递归错误:</p><pre><code>def __setattr__(self, name, value):    self.name = value    # 每一次属性赋值时, __setattr__都会被调用，因此不断调用自身导致无限递归了。</code></pre><p>因此正确的写法应该是:</p><pre><code>def __setattr__(self, name, value):    self.__dict__[name] = value</code></pre><p><code>__delattr__</code>如果在其实现中出现<code>del self.name</code> 这样的代码也会出现”无限递归”错误，这是一样的原因。</p><p>下面的例子很好的说明了上面介绍的4个魔术方法的调用情况:</p><pre><code>class Access(object):    def __getattr__(self, name):        print &apos;__getattr__&apos;        return super(Access, self).__getattr__(name)    def __setattr__(self, name, value):        print &apos;__setattr__&apos;        return super(Access, self).__setattr__(name, value)    def __delattr__(self, name):        print &apos;__delattr__&apos;        return super(Access, self).__delattr__(name)    def __getattribute__(self, name):        print &apos;__getattribute__&apos;        return super(Access, self).__getattribute__(name)access = Access()access.attr1 = True  # __setattr__调用access.attr1  # 属性存在,只有__getattribute__调用try:    access.attr2  # 属性不存在, 先调用__getattribute__, 后调用__getattr__except AttributeError:    passdel access.attr1  # __delattr__调用</code></pre><h2 id="描述器对象"><a href="#描述器对象" class="headerlink" title="描述器对象"></a>描述器对象</h2><p>我们从一个例子来入手,介绍什么是描述符,并介绍<code>__get__</code>, <code>__set__</code>, <code>__delete__</code> 的使用。(放在这里介绍是为了跟上一小节介绍的魔术方法作对比)</p><p>我们知道，距离既可以用单位”米”表示,也可以用单位”英尺”表示。<br>现在我们定义一个类来表示距离,它有两个属性: 米和英尺。</p><pre><code>class Meter(object):    &apos;&apos;&apos;Descriptor for a meter.&apos;&apos;&apos;    def __init__(self, value=0.0):        self.value = float(value)    def __get__(self, instance, owner):        return self.value    def __set__(self, instance, value):        self.value = float(value)class Foot(object):    &apos;&apos;&apos;Descriptor for a foot.&apos;&apos;&apos;    def __get__(self, instance, owner):        return instance.meter * 3.2808    def __set__(self, instance, value):        instance.meter = float(value) / 3.2808class Distance(object):    meter = Meter()    foot = Foot()d = Distance()print d.meter, d.foot  # 0.0, 0.0d.meter = 1print d.meter, d.foot  # 1.0 3.2808d.meter = 2print d.meter, d.foot  # 2.0 6.5616</code></pre><p>在上面例子中,在还没有对Distance的实例赋值前, 我们认为meter和foot应该是各自类的实例对象, 但是输出却是数值。这是因为<code>__get__</code>发挥了作用.</p><p>我们只是修改了meter,并且将其赋值成为int，但foot也修改了。这是<code>__set__</code>发挥了作用.</p><p>描述器对象(Meter、Foot)不能独立存在, 它需要被另一个所有者类(Distance)所持有。<br>描述器对象可以访问到其拥有者实例的属性，比如例子中Foot的<code>instance.meter</code>。</p><p>在面向对象编程时，如果一个类的属性有相互依赖的关系时，使用描述器来编写代码可以很巧妙的组织逻辑。<br>在Django的ORM中, models.Model中的IntegerField等, 就是通过描述器来实现功能的。</p><p>一个类要成为描述器，必须实现<code>__get__</code>, <code>__set__</code>, <code>__delete__</code> 中的至少一个方法。下面简单介绍下:</p><p><code>__get__(self, instance, owner)</code></p><p>参数instance是拥有者类的实例。参数owner是拥有者类本身。<code>__get__</code>在其拥有者对其读值的时候调用。</p><p><code>__set__(self, instance, value)</code></p><p><code>__set__</code>在其拥有者对其进行修改值的时候调用。</p><p><code>__delete__(self, instance)</code></p><p><code>__delete__</code>在其拥有者对其进行删除的时候调用。</p><h2 id="构造自定义容器-Container"><a href="#构造自定义容器-Container" class="headerlink" title="构造自定义容器(Container)"></a>构造自定义容器(Container)</h2><p>在Python中，常见的容器类型有: dict, tuple, list, string。<br>其中tuple, string是不可变容器，dict, list是可变容器。<br>可变容器和不可变容器的区别在于，不可变容器一旦赋值后，不可对其中的某个元素进行修改。<br>比如定义了<code>l = [1, 2, 3]</code>和<code>t = (1, 2, 3)</code>后, 执行<code>l[0] = 0</code>是可以的，但执行<code>t[0] = 0</code>则会报错。</p><p>如果我们要自定义一些数据结构，使之能够跟以上的容器类型表现一样，那就需要去实现某些协议。</p><p>这里的协议跟其他语言中所谓的”接口”概念很像，一样的需要你去实现才行，只不过没那么正式而已。</p><p>如果要自定义不可变容器类型，只需要定义<code>__len__</code> 和 <code>__getitem__</code>方法;<br>如果要自定义可变容器类型，还需要在不可变容器类型的基础上增加定义<code>__setitem__</code> 和 <code>__delitem__</code>。<br>如果你希望你的自定义数据结构还支持”可迭代”, 那就还需要定义<code>__iter__</code>。</p><p><code>__len__(self)</code></p><p>需要返回数值类型，以表示容器的长度。该方法在可变容器和不可变容器中必须实现。</p><p><code>__getitem__(self, key)</code></p><p>当你执行<code>self[key]</code>的时候，调用的就是该方法。该方法在可变容器和不可变容器中也都必须实现。<br>调用的时候,如果key的类型错误，该方法应该抛出TypeError；<br>如果没法返回key对应的数值时,该方法应该抛出ValueError。</p><p><code>__setitem__(self, key, value)</code></p><p>当你执行<code>self[key] = value</code>时，调用的是该方法。</p><p><code>__delitem__(self, key)</code></p><p>当你执行<code>del self[key]</code>的时候，调用的是该方法。</p><p><code>__iter__(self)</code></p><p>该方法需要返回一个迭代器(iterator)。当你执行<code>for x in container:</code> 或者使用<code>iter(container)</code>时，该方法被调用。</p><p><code>__reversed__(self)</code></p><p>如果想要该数据结构被內建函数<code>reversed()</code>支持,就还需要实现该方法。</p><p><code>__contains__(self, item)</code></p><p>如果定义了该方法，那么在执行<code>item in container</code> 或者 <code>item not in container</code>时该方法就会被调用。<br>如果没有定义，那么Python会迭代容器中的元素来一个一个比较，从而决定返回True或者False。</p><p><code>__missing__(self, key)</code></p><p><code>dict</code>字典类型会有该方法，它定义了key如果在容器中找不到时触发的行为。<br>比如<code>d = {&#39;a&#39;: 1}</code>, 当你执行<code>d[notexist]</code>时，<code>d.__missing__(&#39;notexist&#39;)</code>就会被调用。</p><p>下面举例，使用上面讲的魔术方法来实现Haskell语言中的一个数据结构。</p><pre><code># -*- coding: utf-8 -*-class FunctionalList:    &apos;&apos;&apos; 实现了内置类型list的功能,并丰富了一些其他方法: head, tail, init, last, drop, take&apos;&apos;&apos;    def __init__(self, values=None):        if values is None:            self.values = []        else:            self.values = values    def __len__(self):        return len(self.values)    def __getitem__(self, key):        return self.values[key]    def __setitem__(self, key, value):        self.values[key] = value    def __delitem__(self, key):        del self.values[key]    def __iter__(self):        return iter(self.values)    def __reversed__(self):        return FunctionalList(reversed(self.values))    def append(self, value):        self.values.append(value)    def head(self):        # 获取第一个元素        return self.values[0]    def tail(self):        # 获取第一个元素之后的所有元素        return self.values[1:]    def init(self):        # 获取最后一个元素之前的所有元素        return self.values[:-1]    def last(self):        # 获取最后一个元素        return self.values[-1]    def drop(self, n):        # 获取所有元素，除了前N个        return self.values[n:]    def take(self, n):        # 获取前N个元素        return self.values[:n]</code></pre><p>我们再举个例子，实现Perl语言的AutoVivification,它会在你每次引用一个值未定义的属性时为你自动创建数组或者字典。</p><pre><code>class AutoVivification(dict):    &quot;&quot;&quot;Implementation of perl&apos;s autovivification feature.&quot;&quot;&quot;    def __missing__(self, key):        value = self[key] = type(self)()        return valueweather = AutoVivification()weather[&apos;china&apos;][&apos;guangdong&apos;][&apos;shenzhen&apos;] = &apos;sunny&apos;weather[&apos;china&apos;][&apos;hubei&apos;][&apos;wuhan&apos;] = &apos;windy&apos;weather[&apos;USA&apos;][&apos;California&apos;][&apos;Los Angeles&apos;] = &apos;sunny&apos;print weather结果输出:{&apos;china&apos;: {&apos;hubei&apos;: {&apos;wuhan&apos;: &apos;windy&apos;}, &apos;guangdong&apos;: {&apos;shenzhen&apos;: &apos;sunny&apos;}}, &apos;USA&apos;:    {&apos;California&apos;: {&apos;Los Angeles&apos;: &apos;sunny&apos;}}}</code></pre><p>在Python中，关于自定义容器的实现还有更多实用的例子，但只有很少一部分能够集成在Python标准库中，比如<a href="https://docs.python.org/2/library/collections.html">Counter, OrderedDict等</a></p><h2 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h2><p><code>with</code>声明是从Python2.5开始引进的关键词。你应该遇过这样子的代码:</p><pre><code>with open(&apos;foo.txt&apos;) as bar:    # do something with bar</code></pre><p>在with声明的代码段中，我们可以做一些对象的开始操作和清除操作,还能对异常进行处理。<br>这需要实现两个魔术方法: <code>__enter__</code> 和 <code>__exit__</code>。</p><p><code>__enter__(self)</code></p><p><code>__enter__</code>会返回一个值，并赋值给<code>as</code>关键词之后的变量。在这里，你可以定义代码段开始的一些操作。</p><p><code>__exit__(self, exception_type, exception_value, traceback)</code></p><p><code>__exit__</code>定义了代码段结束后的一些操作，可以这里执行一些清除操作，或者做一些代码段结束后需要立即执行的命令，比如文件的关闭，socket断开等。如果代码段成功结束，那么exception_type, exception_value, traceback 三个参数传进来时都将为None。如果代码段抛出异常，那么传进来的三个参数将分别为: 异常的类型，异常的值，异常的追踪栈。<br>如果<code>__exit__</code>返回True, 那么with声明下的代码段的一切异常将会被屏蔽。<br>如果<code>__exit__</code>返回None, 那么如果有异常，异常将正常抛出，这时候with的作用将不会显现出来。</p><p>举例说明：</p><p>这该示例中，IndexError始终会被隐藏，而TypeError始终会抛出。</p><pre><code>class DemoManager(object):    def __enter__(self):        pass    def __exit__(self, ex_type, ex_value, ex_tb):        if ex_type is IndexError:            print ex_value.__class__            return True        if ex_type is TypeError:            print ex_value.__class__            return  # return Nonewith DemoManager() as nothing:    data = [1, 2, 3]    data[4]  # raise IndexError, 该异常被__exit__处理了with DemoManager() as nothing:    data = [1, 2, 3]    data[&apos;a&apos;]  # raise TypeError, 该异常没有被__exit__处理输出:&lt;type &apos;exceptions.IndexError&apos;&gt;&lt;type &apos;exceptions.TypeError&apos;&gt;Traceback (most recent call last):  ...</code></pre><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p>Python对象的序列化操作是pickling进行的。pickling非常的重要，以至于Python对此有单独的模块<code>pickle</code>，还有一些相关的魔术方法。使用pickling, 你可以将数据存储在文件中，之后又从文件中进行恢复。</p><p>下面举例来描述pickle的操作。从该例子中也可以看出,如果通过pickle.load 初始化一个对象, 并不会调用<code>__init__</code>方法。</p><pre><code># -*- coding: utf-8 -*-from datetime import datetimeimport pickleclass Distance(object):    def __init__(self, meter):        print &apos;distance __init__&apos;        self.meter = meterdata = {    &apos;foo&apos;: [1, 2, 3],    &apos;bar&apos;: (&apos;Hello&apos;, &apos;world!&apos;),    &apos;baz&apos;: True,    &apos;dt&apos;: datetime(2016, 10, 01),    &apos;distance&apos;: Distance(1.78),}print &apos;before dump:&apos;, datawith open(&apos;data.pkl&apos;, &apos;wb&apos;) as jar:    pickle.dump(data, jar)  # 将数据存储在文件中del dataprint &apos;data is deleted!&apos;with open(&apos;data.pkl&apos;, &apos;rb&apos;) as jar:    data = pickle.load(jar)  # 从文件中恢复数据print &apos;after load:&apos;, data</code></pre><p>值得一提，从其他文件进行pickle.load操作时，需要注意有恶意代码的可能性。另外，Python的各个版本之间,pickle文件可能是互不兼容的。</p><p>pickling并不是Python的內建类型，它支持所有实现pickle协议(可理解为接口)的类。pickle协议有以下几个可选方法来自定义Python对象的行为。</p><p><code>__getinitargs__(self)</code></p><p>如果你希望unpickle时，<code>__init__</code>方法能够调用，那么就需要定义<code>__getinitargs__</code>, 该方法需要返回一系列参数的元组，这些参数就是传给<code>__init__</code>的参数。</p><p>该方法只对<code>old-style class</code>有效。所谓<code>old-style class</code>,指的是不继承自任何对象的类，往往定义时这样表示: <code>class A:</code>, 而非<code>class A(object):</code></p><p><code>__getnewargs__(self)</code></p><p>跟<code>__getinitargs__</code>很类似，只不过返回的参数元组将传值给<code>__new__</code></p><p><code>__getstate__(self)</code></p><p>在调用<code>pickle.dump</code>时，默认是对象的<code>__dict__</code>属性被存储，如果你要修改这种行为，可以在<code>__getstate__</code>方法中返回一个state。state将在调用<code>pickle.load</code>时传值给<code>__setstate__</code></p><p><code>__setstate__(self, state)</code></p><p>一般来说,定义了<code>__getstate__</code>,就需要相应地定义<code>__setstate__</code>来对<code>__getstate__</code>返回的state进行处理。</p><p><code>__reduce__(self)</code></p><p>如果pickle的数据包含了自定义的扩展类（比如使用C语言实现的Python扩展类）时，就需要通过实现<code>__reduce__</code>方法来控制行为了。由于使用过于生僻，这里就不展开继续讲解了。</p><p>令人容易混淆的是，我们知道, <code>reduce()</code>是Python的一个內建函数, 需要指出<code>__reduce__</code>并非定义了<code>reduce()</code>的行为，二者没有关系。</p><p><code>__reduce_ex__(self)</code></p><p><code>__reduce_ex__</code> 是为了兼容性而存在的, 如果定义了<code>__reduce_ex__</code>, 它将代替<code>__reduce__</code> 执行。</p><p>下面的代码示例很有意思，我们定义了一个类Slate(中文是板岩的意思)。这个类能够记录历史上每次写入给它的值,但每次<code>pickle.dump</code>时当前值就会被清空，仅保留了历史。</p><pre><code># -*- coding: utf-8 -*-import pickleimport timeclass Slate:    &apos;&apos;&apos;Class to store a string and a changelog, and forget its value when pickled.&apos;&apos;&apos;    def __init__(self, value):        self.value = value        self.last_change = time.time()        self.history = []    def change(self, new_value):        # 修改value, 将上次的valeu记录在history        self.history.append((self.last_change, self.value))        self.value = new_value        self.last_change = time.time()    def print_changes(self):        print &apos;Changelog for Slate object:&apos;        for k, v in self.history:            print &apos;%s    %s&apos; % (k, v)    def __getstate__(self):        # 故意不返回self.value和self.last_change,        # 以便每次unpickle时清空当前的状态，仅仅保留history        return self.history    def __setstate__(self, state):        self.history = state        self.value, self.last_change = None, Noneslate = Slate(0)time.sleep(0.5)slate.change(100)time.sleep(0.5)slate.change(200)slate.change(300)slate.print_changes()  # 与下面的输出历史对比with open(&apos;slate.pkl&apos;, &apos;wb&apos;) as jar:    pickle.dump(slate, jar)del slate  # delete itwith open(&apos;slate.pkl&apos;, &apos;rb&apos;) as jar:    slate = pickle.load(jar)print &apos;current value:&apos;, slate.value  # Noneprint slate.print_changes()  # 输出历史记录与上面一致</code></pre><h2 id="运算符相关的魔术方法"><a href="#运算符相关的魔术方法" class="headerlink" title="运算符相关的魔术方法"></a>运算符相关的魔术方法</h2><p>运算符相关的魔术方法实在太多了，也很好理解，不打算多讲。在其他语言里，也有重载运算符的操作，所以我们对这些魔术方法已经很了解了。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><code>__cmp__(self, other)</code></p><p>如果该方法返回负数，说明<code>self &lt; other</code>; 返回正数，说明<code>self &gt; other</code>; 返回0说明<code>self == other</code>。<br>强烈不推荐来定义<code>__cmp__</code>, 取而代之, 最好分别定义<code>__lt__</code>等方法从而实现比较功能。<br><code>__cmp__</code>在Python3中被废弃了。</p><p><code>__eq__(self, other)</code></p><p>定义了比较操作符<code>==</code>的行为.</p><p><code>__ne__(self, other)</code></p><p>定义了比较操作符<code>!=</code>的行为.</p><p><code>__lt__(self, other)</code></p><p>定义了比较操作符<code>&lt;</code>的行为.</p><p><code>__gt__(self, other)</code></p><p>定义了比较操作符<code>&gt;</code>的行为.</p><p><code>__le__(self, other)</code></p><p>定义了比较操作符<code>&lt;=</code>的行为.</p><p><code>__ge__(self, other)</code></p><p>定义了比较操作符<code>&gt;=</code>的行为.</p><p>下面我们定义一种类型Word, 它会使用单词的长度来进行大小的比较, 而不是采用str的比较方式。<br>但是为了避免 <code>Word(&#39;bar&#39;) == Word(&#39;foo&#39;)</code> 这种违背直觉的情况出现,并没有定义<code>__eq__</code>, 因此Word会使用它的父类(str)中的<code>__eq__</code>来进行比较。</p><p>下面的例子中也可以看出: 在编程语言中, 如果<code>a &gt;=b and a &lt;= b</code>, 并不能推导出<code>a == b</code>这样的结论。</p><pre><code># -*- coding: utf-8 -*-class Word(str):    &apos;&apos;&apos;存储单词的类，定义比较单词的几种方法&apos;&apos;&apos;    def __new__(cls, word):        # 注意我们必须要用到__new__方法，因为str是不可变类型        # 所以我们必须在创建的时候将它初始化        if &apos; &apos; in word:            print &quot;Value contains spaces. Truncating to first space.&quot;            word = word[:word.index(&apos; &apos;)]  # 单词是第一个空格之前的所有字符        return str.__new__(cls, word)    def __gt__(self, other):        return len(self) &gt; len(other)    def __lt__(self, other):        return len(self) &lt; len(other)    def __ge__(self, other):        return len(self) &gt;= len(other)    def __le__(self, other):        return len(self) &lt;= len(other)print &apos;foo &lt; fool:&apos;, Word(&apos;foo&apos;) &lt; Word(&apos;fool&apos;)  # Trueprint &apos;foolish &gt; fool:&apos;, Word(&apos;foolish&apos;) &gt; Word(&apos;fool&apos;)  # Trueprint &apos;bar &gt;= foo:&apos;, Word(&apos;bar&apos;) &gt;= Word(&apos;foo&apos;)  # Trueprint &apos;bar &lt;= foo:&apos;, Word(&apos;bar&apos;) &lt;= Word(&apos;foo&apos;)  # Trueprint &apos;bar == foo:&apos;, Word(&apos;bar&apos;) == Word(&apos;foo&apos;)  # False, 用了str内置的比较方法来进行比较print &apos;bar != foo:&apos;, Word(&apos;bar&apos;) != Word(&apos;foo&apos;)  # True</code></pre><h3 id="一元运算符和函数"><a href="#一元运算符和函数" class="headerlink" title="一元运算符和函数"></a>一元运算符和函数</h3><p><code>__pos__(self)</code></p><p>实现了’+’号一元运算符(比如<code>+some_object</code>)</p><p><code>__neg__(self)</code></p><p>实现了’-‘号一元运算符(比如<code>-some_object</code>)</p><p><code>__invert__(self)</code></p><p>实现了<code>~</code>号(波浪号)一元运算符(比如<code>~some_object</code>)</p><p><code>__abs__(self)</code></p><p>实现了<code>abs()</code>內建函数.</p><p><code>__round__(self, n)</code></p><p>实现了<code>round()</code>内建函数. 参数n表示四舍五进的精度.</p><p><code>__floor__(self)</code></p><p>实现了<code>math.floor()</code>, 向下取整.</p><p><code>__ceil__(self)</code></p><p>实现了<code>math.ceil()</code>, 向上取整.</p><p><code>__trunc__(self)</code></p><p>实现了<code>math.trunc()</code>, 向0取整.</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><code>__add__(self, other)</code></p><p>实现了加号运算.</p><p><code>__sub__(self, other)</code></p><p>实现了减号运算.</p><p><code>__mul__(self, other)</code></p><p>实现了乘法运算.</p><p><code>__floordiv__(self, other)</code></p><p>实现了<code>//</code>运算符.</p><p><code>__div__(self, other)</code></p><p>实现了<code>/</code>运算符. 该方法在Python3中废弃. 原因是Python3中，division默认就是true division.</p><p><code>__truediv__</code>(self, other)</p><p>实现了true division. 只有你声明了<code>from __future__ import division</code>该方法才会生效.</p><p><code>__mod__(self, other)</code></p><p>实现了<code>%</code>运算符, 取余运算.</p><p><code>__divmod__(self, other)</code></p><p>实现了<code>divmod()</code>內建函数.</p><p><code>__pow__(self, other)</code></p><p>实现了<code>**</code>操作. N次方操作.</p><p><code>__lshift__(self, other)</code></p><p>实现了位操作<code>&lt;&lt;</code>.</p><p><code>__rshift__(self, other)</code></p><p>实现了位操作<code>&gt;&gt;</code>.</p><p><code>__and__(self, other)</code></p><p>实现了位操作<code>&amp;</code>.</p><p><code>__or__(self, other)</code></p><p>实现了位操作<code>|</code></p><p><code>__xor__(self, other)</code></p><p>实现了位操作<code>^</code></p><h3 id="反算术运算符"><a href="#反算术运算符" class="headerlink" title="反算术运算符"></a>反算术运算符</h3><p>这里只需要解释一下概念即可。<br>假设针对some_object这个对象:</p><pre><code>some_object + other</code></pre><p>上面的代码非常正常地实现了some_object的<code>__add__</code>方法。那么如果遇到相反的情况呢?</p><pre><code>other + some_object</code></pre><p>这时候，如果other没有定义<code>__add__</code>方法，但是some_object定义了<code>__radd__</code>, 那么上面的代码照样可以运行。<br>这里的<code>__radd__(self, other)</code>就是<code>__add__(self, other)</code>的反算术运算符。</p><p>所以，类比的，我们就知道了更多的反算术运算符, 就不一一展开了:</p><ul><li><code>__rsub__(self, other)</code></li><li><code>__rmul__(self, other)</code></li><li><code>__rmul__(self, other)</code></li><li><code>__rfloordiv__(self, other)</code></li><li><code>__rdiv__(self, other)</code></li><li><code>__rtruediv__(self, other)</code></li><li><code>__rmod__(self, other)</code></li><li><code>__rdivmod__(self, other)</code></li><li><code>__rpow__(self, other)</code></li><li><code>__rlshift__(self, other)</code></li><li><code>__rrshift__(self, other)</code></li><li><code>__rand__(self, other)</code></li><li><code>__ror__(self, other)</code></li><li><code>__rxor__(self, other)</code></li></ul><h3 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值"></a>增量赋值</h3><p>这也是只要理解了概念就容易掌握的运算。举个例子:</p><pre><code>x = 5x += 1  # 这里的+=就是增量赋值，将x+1赋值给了x</code></pre><p>因此对于<code>a += b</code>, <code>__iadd__</code> 将返回<code>a + b</code>, 并赋值给a。<br>所以很容易理解下面的魔术方法了:</p><ul><li><code>__iadd__(self, other)</code></li><li><code>__isub__(self, other)</code></li><li><code>__imul__(self, other)</code></li><li><code>__ifloordiv__(self, other)</code></li><li><code>__idiv__(self, other)</code></li><li><code>__itruediv__(self, other)</code></li><li><code>__imod__(self, other)</code></li><li><code>__ipow__(self, other)</code></li><li><code>__ilshift__(self, other)</code></li><li><code>__irshift__(self, other)</code></li><li><code>__iand__(self, other)</code></li><li><code>__ior__(self, other)</code></li><li><code>__ixor__(self, other)</code></li></ul><h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><p><code>__int__(self)</code></p><p>实现了类型转化为int的行为.</p><p><code>__long__(self)</code></p><p>实现了类型转化为long的行为.</p><p><code>__float__(self)</code></p><p>实现了类型转化为float的行为.</p><p><code>__complex__(self)</code></p><p>实现了类型转化为complex(复数, 也即1+2j这样的虚数)的行为.</p><p><code>__oct__(self)</code></p><p>实现了类型转化为八进制数的行为.</p><p><code>__hex__(self)</code></p><p>实现了类型转化为十六进制数的行为.</p><p><code>__index__(self)</code></p><p>在切片运算中将对象转化为int, 因此该方法的返回值必须是int。用一个例子来解释这个用法。</p><pre><code>class Thing(object):    def __index__(self):        return 1thing = Thing()list_ = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]print list_[thing]  # &apos;b&apos;print list_[thing:thing]  # []</code></pre><p>上面例子中, <code>list_[thing]</code>的表现跟<code>list_[1]</code>一致，正是因为Thing实现了<code>__index__</code>方法。</p><p>可能有的人会想，<code>list_[thing]</code>为什么不是相当于<code>list_[int(thing)]</code>呢? 通过实现Thing的<code>__int__</code>方法能否达到这个目的呢?</p><p>显然不能。如果真的是这样的话，那么<code>list_[1.1:2.2]</code>这样的写法也应该是通过的。<br>而实际上，该写法会抛出TypeError: <code>slice indices must be integers or None or have an __index__ method</code></p><p>下面我们再做个例子,如果对一个dict对象执行<code>dict_[thing]</code>会怎么样呢?</p><pre><code>dict_ = {1: &apos;apple&apos;, 2: &apos;banana&apos;, 3: &apos;cat&apos;}print dict_[thing]  # raise KeyError</code></pre><p>这个时候就不是调用<code>__index__</code>了。虽然<code>list</code>和<code>dict</code>都实现了<code>__getitem__</code>方法, 但是它们的实现方式是不一样的。<br>如果希望上面例子能够正常执行, 需要实现Thing的<code>__hash__</code> 和 <code>__eq__</code>方法.</p><pre><code>class Thing(object):    def __hash__(self):        return 1    def __eq__(self, other):        return hash(self) == hash(other)dict_ = {1: &apos;apple&apos;, 2: &apos;banana&apos;, 3: &apos;cat&apos;}print dict_[thing]  # apple</code></pre><p><code>__coerce__(self, other)</code></p><p>实现了混合模式运算。</p><p>要了解这个方法,需要先了解<code>coerce()</code>内建函数: <a href="https://docs.python.org/2/library/functions.html#coerce">官方文档</a>上的解释是, coerce(x, y)返回一组数字类型的参数, 它们被转化为同一种类型，以便它们可以使用相同的算术运算符进行操作。如果过程中转化失败，抛出TypeError。</p><p>比如对于<code>coerce(10, 10.1)</code>, 因为10和10.1在进行算术运算时，会先将10转为10.0再来运算。因此<code>coerce(10, 10.1)</code>返回值是(10.0, 10.1).</p><p><code>__coerce__</code>在Python3中废弃了。</p><h2 id="其他魔术方法"><a href="#其他魔术方法" class="headerlink" title="其他魔术方法"></a>其他魔术方法</h2><p>还没讲到的魔术方法还有很多，但有些我觉得很简单，或者很少见，就不再累赘展开说明了。</p><p><code>__str__(self)</code></p><p>对实例使用<code>str()</code>时调用。</p><p><code>__repr__(self)</code></p><p>对实例使用<code>repr()</code>时调用。<code>str()</code>和<code>repr()</code>都是返回一个代表该实例的字符串，<br>主要区别在于: str()的返回值要方便人来看,而repr()的返回值要方便计算机看。</p><p><code>__unicode__(self)</code></p><p>对实例使用<code>unicode()</code>时调用。<code>unicode()</code>与<code>str()</code>的区别在于: 前者返回值是unicode, 后者返回值是str。unicode和str都是<code>basestring</code>的子类。</p><p>当你对一个类只定义了<code>__str__</code>但没定义<code>__unicode__</code>时,<code>__unicode__</code>会根据<code>__str__</code>的返回值自动实现,即<code>return unicode(self.__str__())</code>;<br>但返回来则不成立。</p><pre><code>class StrDemo2:    def __str__(self):        return &apos;StrDemo2&apos;class StrDemo3:    def __unicode__(self):        return u&apos;StrDemo3&apos;demo2 = StrDemo2()print str(demo2)  # StrDemo2print unicode(demo2)  # StrDemo2demo3 = StrDemo3()print str(demo3)  # &lt;__main__.StrDemo3 instance&gt;print unicode(demo3)  # StrDemo3</code></pre><p><code>__format__(self, formatstr)</code></p><p><code>&quot;Hello, {0:abc}&quot;.format(a)</code>等价于<code>format(a, &quot;abc&quot;)</code>, 等价于<code>a.__format__(&quot;abc&quot;)</code>。</p><p>这在需要格式化展示对象的时候非常有用，比如格式化时间对象。</p><p><code>__hash__(self)</code></p><p>对实例使用<code>hash()</code>时调用, 返回值是数值类型。</p><p><code>__nonzero__(self)</code></p><p>对实例使用<code>bool()</code>时调用, 返回True或者False。<br>你可能会问, 为什么不是命名为<code>__bool__</code>? 我也不知道。<br>我只知道该方法在Python3中改名为<code>__bool__</code>了。</p><p><code>__dir__(self)</code></p><p>对实例使用<code>dir()</code>时调用。通常实现该方法是没必要的。</p><p><code>__sizeof__(self)</code></p><p>对实例使用<code>sys.getsizeof()</code>时调用。返回对象的大小，单位是bytes。</p><p><code>__instancecheck__(self, instance)</code></p><p>对实例调用<code>isinstance(instance, class)</code>时调用。 返回值是布尔值。它会判断instance是否是该类的实例。</p><p><code>__subclasscheck__(self, subclass)</code></p><p>对实例使用<code>issubclass(subclass, class)</code>时调用。返回值是布尔值。它会判断subclass否是该类的子类。</p><p><code>__copy__(self)</code></p><p>对实例使用<code>copy.copy()</code>时调用。返回”浅复制”的对象。</p><p><code>__deepcopy__(self, memodict={})</code></p><p>对实例使用<code>copy.deepcopy()</code>时调用。返回”深复制”的对象。</p><p><code>__call__(self, [args...])</code></p><p>该方法允许类的实例跟函数一样表现:</p><pre><code>class XClass:    def __call__(self, a, b):        return a + bdef add(a, b):    return a + bx = XClass()print &apos;x(1, 2)&apos;, x(1, 2)print &apos;callable(x)&apos;, callable(x)  # Trueprint &apos;add(1, 2)&apos;, add(1, 2)print &apos;callable(add)&apos;, callable(add)  # True</code></pre><h2 id="Python3中的差异"><a href="#Python3中的差异" class="headerlink" title="Python3中的差异"></a>Python3中的差异</h2><ul><li>Python3中，str与unicode的区别被废除了,因而<code>__unicode__</code>没有了，取而代之地出现了<code>__bytes__</code>.</li><li>Python3中，division默认就是true division, 因而<code>__div__</code>废弃.</li><li><code>__coerce__</code>因存在冗余而废弃.</li><li><code>__cmp__</code>因存在冗余而废弃.</li><li><code>__nonzero__</code>改名为<code>__bool__</code>.</li></ul>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解python的metaclass</title>
      <link href="/posts/intro-python-metaclass/"/>
      <url>/posts/intro-python-metaclass/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客是我在stackoverflow上看了一个提问回复后写的,例子基本用的都是e-satis本人的例子，语言组织也基本按照翻译来。</p><p>但我并不是一个翻译者,并不会严格遵守每行每句的翻译;<br>有时候我会将表述换个顺序,省略一些我认为无关紧要的话，以便读者更好理解。</p><p>所以，如果你不喜欢我的语言表述，或者想要看英文原文，可以去查看<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">原回复</a>。</p><h2 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h2><p>在理解metaclass之前，我们先要掌握python中的类<code>class</code>是什么。<br>python中类的概念，是借鉴自smalltalk语言。<br>在大部分语言中，类指的是”描述如何产生一个对象(object)”的一段代码，这对于python也是如此。</p><pre><code>&gt;&gt;&gt; class ObjectCreator(object):...       pass...&gt;&gt;&gt; my_object = ObjectCreator()&gt;&gt;&gt; print(my_object)&lt;__main__.ObjectCreator object at 0x8974f2c&gt;</code></pre><p>但是,在python中，类远不止如此，类同时也是对象。<br>当你遇到关键词<code>class</code>的时候，python就会自动执行产生一个对象。下面的代码段中:</p><pre><code>&gt;&gt;&gt; class ObjectCreator(object):...       pass...</code></pre><p>python在内存中产生了一个名叫做”ObjectCreator”的对象。这个对象(类)自身拥有产生对象(实例instance)的能力。 这就是为什么称呼这东西(后面遇到容易混淆的地方,我们称之为:类对象)也是类的原因。同时，它也是一个对象，因此你可以对它做如下操作:</p><ul><li>赋值给变量</li><li>复制它</li><li>为它增加属性(attribute)</li><li>作为参数传值给函数</li></ul><p>举例：</p><pre><code>&gt;&gt;&gt; print(ObjectCreator) # 你可以打印一个类,因为它同时也是对象&lt;class &apos;__main__.ObjectCreator&apos;&gt;&gt;&gt;&gt; def echo(o):...     print(o)...&gt;&gt;&gt; echo(ObjectCreator) # 作为参数传值给函数&lt;class &apos;__main__.ObjectCreator&apos;&gt;&gt;&gt;&gt; print(hasattr(ObjectCreator, &apos;new_attribute&apos;))False&gt;&gt;&gt; ObjectCreator.new_attribute = &apos;foo&apos; # you can add attributes to a class&gt;&gt;&gt; print(hasattr(ObjectCreator, &apos;new_attribute&apos;))True&gt;&gt;&gt; print(ObjectCreator.new_attribute)foo&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # 将类赋值给变量&gt;&gt;&gt; print(ObjectCreatorMirror.new_attribute)foo&gt;&gt;&gt; print(ObjectCreatorMirror())&lt;__main__.ObjectCreator object at 0x8997b4c&gt;</code></pre><h2 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h2><p>既然类也是对象，那么我们就可以在运行的时候创建它，跟创建对象一样自然。</p><p>首先，我们使用<code>class</code>关键字定义一个产生类的函数:</p><pre><code>&gt;&gt;&gt; def choose_class(name):...     if name == &apos;foo&apos;:...         class Foo(object):...             pass...         return Foo # return the class, not an instance...     else:...         class Bar(object):...             pass...         return Bar...&gt;&gt;&gt; MyClass = choose_class(&apos;foo&apos;)&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance&lt;class &apos;__main__.Foo&apos;&gt;&gt;&gt;&gt; print(MyClass()) # you can create an object from this class&lt;__main__.Foo object at 0x89c6d4c&gt;</code></pre><p>这很容易理解吧。但是，这并不那么动态啊。我们还是需要自己来写这个类的代码。</p><p>既然类也是对象，那就应该有用来产生它的东西。这东西就是<code>type</code>。</p><p>先来说说你所认识的<code>type</code>。这个古老而好用的函数，可以让我们知道一个对象的类型是什么。</p><pre><code>&gt;&gt;&gt; print(type(1))&lt;type &apos;int&apos;&gt;&gt;&gt;&gt; print(type(&quot;1&quot;))&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; print(type(ObjectCreator))&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; print(type(ObjectCreator()))&lt;class &apos;__main__.ObjectCreator&apos;&gt;</code></pre><p>实际上，<code>type</code>还有一个完全不同的功能，它可以在运行时产生类。<code>type</code>可以传入一些参数，然后返回一个类。(好吧，必须承认，根据不同的传入参数，一个相同的函数<code>type</code>居然会有两个完全不同的作用，这很愚蠢。不过python这样做是为了保持向后兼容性。)</p><p>下面举例<code>type</code>创建类的用法。首先，对于类一般是这么定义的:</p><pre><code>&gt;&gt;&gt; class MyShinyClass(object):...       pass</code></pre><p>在下面，MyShinyClass也可以这样子被创建出来,并且跟上面的创建方法有一样的表现:</p><pre><code>&gt;&gt;&gt; MyShinyClass = type(&apos;MyShinyClass&apos;, (), {}) # returns a class object&gt;&gt;&gt; print(MyShinyClass)&lt;class &apos;__main__.MyShinyClass&apos;&gt;&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class&lt;__main__.MyShinyClass object at 0x8997cec&gt;</code></pre><p><code>type</code>创建类需要传入三个参数,分别为:</p><ul><li>类的名字</li><li>一组”类的父类”的元组(tuple) (这个会实现继承,也可以为空)</li><li>字典 (类的属性名与值,key-value的形式，不传相当于为空，如一般写法中的pass).</li></ul><p>下面来点复杂的，来更好的理解<code>type</code>传入的三个参数:</p><pre><code>class Foo(object):    bar = True    def echo_bar(self):        print(self.bar)</code></pre><p>等价于:</p><pre><code>def echo_bar(self):    print(self.bar)Foo = type(&apos;Foo&apos;, (), {&apos;bar&apos;:True, &apos;echo_bar&apos;: echo_bar})</code></pre><p>想要看点有继承关系的类的实现,来:</p><pre><code>class FooChild(Foo):    pass</code></pre><p>等价于:</p><pre><code>FooChild = type(&apos;FooChild&apos;, (Foo, ), {})</code></pre><p>回顾一下我们学到哪了: 在python中，类就是对象，并且你可以在运行的时候动态创建类.</p><h2 id="那到底什么是metaclass-元类"><a href="#那到底什么是metaclass-元类" class="headerlink" title="那到底什么是metaclass(元类)"></a>那到底什么是metaclass(元类)</h2><p>metaclass 就是创建类的那家伙。(事实上，<code>type</code>就是一个metaclass)</p><p>我们知道,我们定义了class就是为了能够创建object的，没错吧?</p><p>我们也学习了，python中类也是对象。</p><p>那么，metaclass就是用来创造“类对象”的类.它是“类对象”的“类”。</p><p>可以这样子来理解:</p><p><img src="http://static.extremevision.com.cn/membercms/python_metaclass_img1.png" alt="图片"></p><pre><code>MyClass = MetaClass()MyObject = MyClass()</code></pre><p>也可以用我们上面学到的<code>type</code>来表示:</p><pre><code>MyClass = type(&apos;MyClass&apos;, (), {})</code></pre><p>说白了,函数<code>type</code>就是一个特殊的metaclass.<br>python在背后使用<code>type</code>创造了所有的类。<code>type</code>是所有类的metaclass.</p><p>我们可以使用<code>__class__</code>属性来验证这个说法.</p><p>在python中，一切皆为对象：整数、字符串、函数、类.所有这些对象，都是通过类来创造的.</p><pre><code>&gt;&gt;&gt; age = 35&gt;&gt;&gt; age.__class__&lt;type &apos;int&apos;&gt;&gt;&gt;&gt; name = &apos;bob&apos;&gt;&gt;&gt; name.__class__&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; def foo(): pass&gt;&gt;&gt; foo.__class__&lt;type &apos;function&apos;&gt;&gt;&gt;&gt; class Bar(object): pass&gt;&gt;&gt; b = Bar()&gt;&gt;&gt; b.__class__&lt;class &apos;__main__.Bar&apos;&gt;</code></pre><p>那么，<code>__class__</code>的<code>__class__</code>又是什么呢?</p><pre><code>&gt;&gt;&gt; age.__class__.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; name.__class__.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; foo.__class__.__class__&lt;type &apos;type&apos;&gt;&gt;&gt;&gt; b.__class__.__class__&lt;type &apos;type&apos;&gt;</code></pre><p>metaclass就是创造类对象的工具.如果你喜欢，你也可以称之为”类的工厂”.</p><p>type是python內置的metaclass。不过，你也可以编写自己的metaclass.</p><h2 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__ 属性"></a><code>__metaclass__</code> 属性</h2><p>我们可以在一个类中加入 <code>__metaclass__</code> 属性.</p><pre><code>class Foo(object):    __metaclass__ = something...    [...]</code></pre><p>当你这么做了，python就会使用metaclass来创造类:Foo。</p><p>注意啦，这里有些技巧的。</p><p>当你写下<code>class Foo(object)</code>的时候，类对象Foo还没有在内存中生成。</p><p>python会在类定义中寻找<code>__metaclass__</code> 。如果找到了，python就会使用这个<code>__metaclass__</code> 来创造类对象: Foo。如果没找到，python就使用type来创造Foo。</p><p>请把下面的几段话重复几遍：</p><p>当你写如下代码的时候:</p><pre><code>class Foo(Bar):    pass</code></pre><p>python做了以下事情:</p><p>Foo中有<code>__metaclass__</code>这个属性吗？<br>如果有，python会在内存中通过<code>__metaclass__</code>创建一个名字为Foo的类对象。<br>如果python没有在Foo中找到<code>__metaclass__</code>，它会继续在Bar（父类）中寻找<code>__metaclass__</code>，并尝试做和前面同样的操作。<br>如果python由下往上遍历父类也都没有找不到<code>__metaclass__</code>，它就会在模块(module)中去寻找<code>__metaclass__</code>，并尝试做同样的操作。<br>如果还是没有找不到<code>__metaclass__</code>， python才会用内置的type(这也是一个metaclass)来创建这个类对象。</p><p>现在问题来了,我们要怎么用代码来实现<code>__metaclass__</code>呢?  写一些可以用来产生类(class)的东西就行。</p><p>那什么可以产生类？无疑就是<code>type</code>，或者<code>type</code>的任何子类,或者任何使用到<code>type</code>的东西都行.</p><h2 id="自定义metaclass"><a href="#自定义metaclass" class="headerlink" title="自定义metaclass"></a>自定义metaclass</h2><p>使用metaclass的主要目的，是为了能够在创建类的时候，自动地修改类。</p><p>一个很傻的需求，我们决定要将该模块中的所有类的属性，改为大写。</p><p>有几种方法可以做到，这里使用<code>__metaclass__</code>来实现.</p><p>在模块的层次定义metaclass,模块中的所有类都会使用它来创造类。我们只需要告诉metaclass,将所有的属性转化为大写。</p><pre><code># type也是一个类，我们可以继承它.class UpperAttrMetaclass(type):    # __new__ 是在__init__之前被调用的特殊方法    # __new__是用来创建对象并返回这个对象    # 而__init__只是将传入的参数初始化给对象    # 实际中,你很少会用到__new__，除非你希望能够控制对象的创建    # 在这里，类是我们要创建的对象，我们希望能够自定义它，所以我们改写了__new__    # 如果你希望的话，你也可以在__init__中做些事情    # 还有一些高级的用法会涉及到改写__call__，但这里我们就先不这样.    def __new__(upperattr_metaclass, future_class_name,                future_class_parents, future_class_attr):        uppercase_attr = {}        for name, val in future_class_attr.items():            if not name.startswith(&apos;__&apos;):                uppercase_attr[name.upper()] = val            else:                uppercase_attr[name] = val        return type(future_class_name, future_class_parents, uppercase_attr)</code></pre><p>这里的方式其实不是OOP(面向对象编程).因为我们直接调用了type,而不是改写父类的<code>__type__</code>方法.</p><p>所以我们也可以这样子处理:</p><pre><code>class UpperAttrMetaclass(type):    def __new__(upperattr_metaclass, future_class_name,                future_class_parents, future_class_attr):        uppercase_attr = {}        for name, val in future_class_attr.items():            if not name.startswith(&apos;__&apos;):                uppercase_attr[name.upper()] = val            else:                uppercase_attr[name] = val        return type.__new__(upperattr_metaclass, future_class_name,                            future_class_parents, uppercase_attr)</code></pre><p>这样子看,我们只是复用了 <code>type.__new__</code>方法,这就是我们熟悉的基本的OOP编程，没什么魔法可言.</p><p>你可能注意到,<code>__new__</code>方法相比于</p><pre><code>type(future_class_name, future_class_parents, future_class_attr)</code></pre><p>多了一个参数: upperattr_metaclass, 请别在意,这没什么特别的: <code>__new__</code>总是将”它要定义的类”作为第一个参数。</p><p>这就好比是 self 在类的一般方法(method)中一样,也是被作为第一个参数传入。</p><p>当然啦，这里的名字的确是我起的太长了。就像self一样，所有的参数都有它们传统的名称。<br>因此，在实际的代码中,一个metaclass应该是写成下面样子的:</p><p>(我们同时使用常见的super来让代码更清晰)</p><pre><code>class UpperAttrMetaclass(type):    def __new__(cls, clsname, bases, attrs):        uppercase_attr = {}        for name, val in attrs.items():            if not name.startswith(&apos;__&apos;):                uppercase_attr[name.upper()] = val            else:                uppercase_attr[name] = val        return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, attrs)</code></pre><p>使用了 metaclass 的代码是比较复杂，但我们使用它的原因并不是为了复杂, 而是因为我们通常会使用 metaclass  去做一些晦涩的事情,比如, 依赖于自省，控制继承等等。</p><p>确实，用 metaclass 来搞些“黑魔法”是特别有用的，因而会复杂化代码。</p><p>但就metaclass本身而言，它们其实是很简单的：中断类的默认创建、修改类、最后返回修改后的类.</p><h2 id="到底为什么要使用metaclass"><a href="#到底为什么要使用metaclass" class="headerlink" title="到底为什么要使用metaclass"></a>到底为什么要使用metaclass</h2><p>现在我们面临一个问题: 为什么要使用metaclass? 它容易出错且晦涩难懂.</p><p>好吧，一般来说，我们根本就用不上它, 99%的用户应该根本不必为此操心。</p><p>实际用到metaclass的人，很清楚他们到底需要做什么,根本不用解释为什么要用.</p><p>metaclass 的一个主要用途就是构建API。Django(一个python写的web框架)的ORM 就是一个例子。</p><p>用Django先定义了以下Model:</p><pre><code>class Person(models.Model):    name = models.CharField(max_length=30)    age = models.IntegerField()</code></pre><p>然后执行下面代码:</p><pre><code>guy = Person.objects.get(name=&apos;bob&apos;)print guy.age  # result is 35</code></pre><p>这里打印的输出并不是<code>IntegerField</code>，而是一个<code>int</code>，<code>int</code>是从数据库中获取的.</p><p>这是因为 <code>models.Model</code> 使用 <code>__metaclass__</code>来实现了复杂的数据库查询。但对于你看来,这就是简单的API而已,不用关心背后的复杂工作。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>复习一下,我们知道了,类是能够创造对象实例的对象，同时也是metaclass的对象实例(因为metaclass创造了它们).</p><p>在python中，一切皆为对象。它们要么是类的实例，要么是metaclass的实例, 除了type。</p><p>type是它自身的metaclass。至于是怎么实现的，总之纯python语言是不可能实现的,这需要在实现层面上耍一些小手段才能做到的。</p><p>metaclass用起来比较复杂, 如果需要对非常简单的类进行修改, 你可能不会使用它。有以下两个技术可以供你选择:</p><ul><li><a href="https://en.wikipedia.org/wiki/Monkey_patch">猴子修补 Monkey patch</a></li><li>类修饰器</li></ul>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用rsync在windows电脑上实现文件同步</title>
      <link href="/posts/use-rsync-on-windows/"/>
      <url>/posts/use-rsync-on-windows/</url>
      <content type="html"><![CDATA[<p>本文将在一台Linux服务器A上搭建rsync文件同步服务，然后在另一台windows电脑B上保持与A的单向同步。</p><h2 id="一个具体的案例"><a href="#一个具体的案例" class="headerlink" title="一个具体的案例"></a>一个具体的案例</h2><p>某技术公司A的业务，会在服务器上生产pdf电子书、相册等文件，但是公司A本身不具备打印技术，需要转交给传统打印公司B来完成线下生产。那么问题来了，公司A怎么将每天生产出来几十个G的文件，以最小的成本传输给B呢？B公司是传统小企业，并不懂电脑技术,而且连接打印机的电脑是windows系统的.</p><p>一个自然而然想到的方案，就是借助第三方云盘服务C，公司A将文件上传C，然后公司B再从C上下载。这个方案可行，但是多了上传到传输节点C的步骤，增加了A上传C的这段时间成本。</p><p>一个简单的实施方案，就是在A上搭建rsync服务，然后告知B来同步。好在rsync提供的windows的版本，让这个方案可行。当然，该方案也适用于Mac/Linux,而且更简单。</p><h2 id="服务端操作"><a href="#服务端操作" class="headerlink" title="服务端操作"></a>服务端操作</h2><p>以centos为例，安装rsync:</p><pre><code>yum -y install rsync</code></pre><p>直接启动rsync:</p><pre><code>rsync --daemon --config=/etc/rsyncd.conf</code></pre><p>执行 <code>ps -ef | grep rsync</code> 可以看到服务已经成功启动.</p><p>安装rsync时默认生成了配置文件 <code>/etc/rsyncd.conf</code> , 下面讲解一下配置文件. 完整的配置如下:</p><pre><code>uid = rootgid = rootuse chroot = yesmax connections = 4pid file = /var/run/rsyncd.pidexclude = lost+found/transfer logging = yestimeout = 900ignore nonreadable = yesdont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2[test01]path = /root/tmp/test01/read only = yes[test02]path = /root/tmp/test02/read only = yes</code></pre><p><code>[test01]</code>一行以上的内容，与默认的配置无异，我们采用默认的配置即可.</p><p>然后在文件的最后加上以下配置。表示我们要启动两个提供同步的目录,分别命名为test01和test02，路径分别为<code>/root/tmp/test01/</code> 和 <code>/root/tmp/test02/</code>.</p><p>这里的test01 和 test02 在文档中叫做 <code>module name</code>,我们可以理解为”别名”、”alias”的意思即可.</p><p>read only = yes 表示客户端只能下载服务端的文件而不能上传(单向同步).<br>这应该是大部分业务的需求,如果有上传需要,设置read only = no 即可.</p><p>有一点需要提醒, <code>/etc/rsyncd.conf</code>配置修改后,并不需要重启服务即可生效.</p><p>如果想要关闭rsync服务,执行<code>ps -ef | pgrep rsync | xargs kill</code> 即可.</p><p>为了方便测试,我们还需要创建/root/tmp/test01/ 和 /root/tmp/test02/ 两个目录,然后在目录里面创建一些文件和目录,以便能看到同步下载的效果.</p><p>如果想要了解更多的配置和启动项，可以执行以下命令查看,这里不再赘言:</p><ul><li><code>man rsyncd.conf</code> 查看更多文档</li><li>或者<code>rsync --daemon --help</code> 查看rsync的启动参数</li></ul><p>rsync的默认端口是873, 如果服务器有防火墙限制,需要开放873端口:</p><pre><code>iptables -I INPUT -p tcp --dport 873 -j ACCEPT</code></pre><p>如果服务器是部署在阿里云等云平台上，那可能还需要在云平台上调整安全组的出入网规则。</p><h2 id="客户端操作-mac-linux"><a href="#客户端操作-mac-linux" class="headerlink" title="客户端操作(mac/linux)"></a>客户端操作(mac/linux)</h2><p>测试一下命令(假设A的IP是192.168.1.100):</p><pre><code>rsync -r --list-only  192.168.1.100::test01</code></pre><p>该命令中,</p><pre><code>-r 参数表示要递归同步目录下的目录.--list-only 参数表示只输出,不执行真正的文件传输.192.168.1.100 是服务器的IP，你可以替换成相应的域名.test01 就是我们配置中指定的module name, 请记住, test01前面是两个冒号.</code></pre><p>如果能够列出服务器上test01对应的目录内容,则表示同步已经成功.</p><p>如果发生错误 <code>rsync: failed to connect to [你的服务器]: Operation timed out</code>，在检查网络正常的情况下,可能就是我们上面提到的防火墙问题。</p><p>执行同步命令:</p><pre><code>rsync -avP --delete --chmod=a=rwx 192.168.1.100::test01  ./tmpfolder</code></pre><p>解释一下参数:</p><pre><code>--delete 表示删除本地tmpfolder目录中跟服务器test01下不一致的所有文件和目录--chmod=a=rwx 表示同步下来的文件具有a=rwx的权限(所有人可读写执行)./tmpfolder 表示同步到本地的该目录下-P 表示显示进度条-v 表示采用增量的方式同步文件-a 是 archive mode; same as -rlptgoD; 相当于简写了很多参数</code></pre><p>另外还有一些常见的参数说明:</p><pre><code>-u, --update      忽略客户端上(比服务端)更加新的文件-r, --recursive   递归同步目录-z, --compress    传输时压缩文件数据</code></pre><p>在这里,我不使用<code>-z</code>参数是因为我要传输的文件主要是pdf和图片,所以该参数作用不大。<br>如果数据以文本为主, 那加上<code>-z</code>会好很多, 传输过程中数据量更少。</p><h2 id="windows下的解决方案"><a href="#windows下的解决方案" class="headerlink" title="windows下的解决方案"></a>windows下的解决方案</h2><p>windows下有软件cwRsync提供了rsync的功能. <a href="http://static.extremevision.com.cn/membercms/cwRsync_5.4.1_x86_Free.zip?attname=">cwRsync的下载地址</a></p><p>安装步骤如下:</p><ul><li>下载<a href="http://static.extremevision.com.cn/membercms/cwRsync_5.4.1_x86_Free.zip?attname=">cwRsync</a></li><li>解压得到的文件夹，将该文件夹加入到环境变量Path中, 比如<code>D:\cwRsync_5.4.1_x86_Free</code>。添加环境变量的方法可参考<a href="http://www.dngsos.com/dngsdnjc/361.html">这里</a></li><li>建立文件夹存放同步的文件，比如<code>D:\pdf_and_album\</code>。</li><li>在<code>D:\cwRsync_5.4.1_x86_Free</code>中, 编写批处理脚本<code>pdf_rsync.bat</code>, 脚本内容如下面的”脚本1”。</li><li>设置windows的定时任务，执行<code>pdf_rsync.bat</code>。windows设置定时任务的方法见<a href="http://jingyan.baidu.com/article/d5c4b52bc3a11cda560dc5a7.html">Win XP</a>, <a href="http://jingyan.baidu.com/article/6181c3e0435026152ef153d0.html">Win 7</a></li></ul><p>脚本1内容就是我们上面提到的命令，比如:</p><pre><code>rsync -avP --delete --chmod=a=rwx rsync.bala.com::test01  /cygdrive/d/pdf_and_album/</code></pre>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
